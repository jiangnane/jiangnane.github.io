<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Android系统分区构成和解析：以AOSP11为例 - HEIN&#x27;s Blog</title><meta name="robots" content="noindex,nofollow"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="alternate" type="application/atom+xml" href="https://blog.nasyes.cn/feed.xml" title="HEIN&#x27;s Blog - RSS"><link rel="alternate" type="application/json" href="https://blog.nasyes.cn/feed.json" title="HEIN&#x27;s Blog - JSON"><meta property="og:title" content="Android系统分区构成和解析：以AOSP11为例"><meta property="og:site_name" content="HEIN's Blog"><meta property="og:description" content="在 Android 11 中，系统分区管理通过多种物理分区来实现设备的引导、系统操作、数据存储和无线通信等功能。Android 11 引入了增强的系统更新机制，如 A/B 分区 和 动态分区，以提高系统的更新效率和安全性。以下是 Android 11 中常见的物理分区介绍： Android 的无缝更新机制基于 A/B 分区架构，而不是依赖于 ext4 的快照功能。以下是它的工作原理： ext4 文件系统的快照功能（例如通过 e2fsprogs 的 e2image 工具或&hellip;"><meta property="og:url" content="https://blog.nasyes.cn/android11xi-tong-fen-qu-jie-shao.html"><meta property="og:type" content="article"><link rel="preload" href="https://blog.nasyes.cn/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://blog.nasyes.cn/assets/css/style.css?v=1f557c81d98d81d721608200b8db7e33"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.nasyes.cn/android11xi-tong-fen-qu-jie-shao.html"},"headline":"Android系统分区构成和解析：以AOSP11为例","datePublished":"2024-09-26T11:20+08:00","dateModified":"2024-09-26T11:34+08:00","description":"在 Android 11 中，系统分区管理通过多种物理分区来实现设备的引导、系统操作、数据存储和无线通信等功能。Android 11 引入了增强的系统更新机制，如 A/B 分区 和 动态分区，以提高系统的更新效率和安全性。以下是 Android 11 中常见的物理分区介绍： Android 的无缝更新机制基于 A/B 分区架构，而不是依赖于 ext4 的快照功能。以下是它的工作原理： ext4 文件系统的快照功能（例如通过 e2fsprogs 的 e2image 工具或&hellip;","author":{"@type":"Person","name":"HEIN","url":"https://blog.nasyes.cn/authors/hein/"},"publisher":{"@type":"Organization","name":"HEIN"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body><div class="container container--center"><header class="header"><div class="header__logo"><a class="logo" href="https://blog.nasyes.cn/">HEIN&#x27;s Blog</a></div></header><main class="content"><article class="post"><header><h1 class="post__title">Android系统分区构成和解析：以AOSP11为例</h1><div class="post__meta"><time datetime="2024-09-26T11:20" class="post__date">九月 26, 2024 </time><span class="post__author"><a href="https://blog.nasyes.cn/authors/hein/" class="feed__author">HEIN</a></span></div></header><div class="post__entry"><p>在 Android 11 中，系统分区管理通过多种物理分区来实现设备的引导、系统操作、数据存储和无线通信等功能。Android 11 引入了增强的系统更新机制，如 <strong>A/B 分区</strong> 和 <strong>动态分区</strong>，以提高系统的更新效率和安全性。以下是 Android 11 中常见的物理分区介绍：</p><h3 id="1-boot-分区">1. <strong>boot 分区</strong></h3><ul><li><strong>功能</strong>: 包含启动引导程序和 Linux 内核，用于设备启动。它加载内核并启动 Android 系统。</li><li><strong>特点</strong>: 该分区包含了设备启动时的关键组件，通常是只读的，只有在系统更新或开发模式下才会被修改。</li></ul><h3 id="2-system-分区">2. <strong>system 分区</strong></h3><ul><li><strong>功能</strong>: 存储 Android 操作系统的核心组件和框架，包括系统应用程序、库文件、系统服务和设置等。</li><li><strong>特点</strong>: Android 11 引入了 <strong>动态分区</strong>（Dynamic Partition），允许系统分区的动态调整和重新划分，而无需对物理分区进行硬性划分。系统更新时，这个分区的大小可以灵活调整。</li></ul><h3 id="3-vendor-分区">3. <strong>vendor 分区</strong></h3><ul><li><strong>功能</strong>: 存储厂商提供的硬件驱动和设备定制代码。它允许设备制造商将特定的硬件抽象层（HAL）独立于系统更新，以支持不同硬件。</li><li><strong>特点</strong>: 随着 Android 系统的模块化，<code>vendor</code> 分区在 Android 11 中变得更为重要，确保不同设备之间的兼容性和稳定性。</li></ul><h3 id="4-userdata-分区">4. <strong>userdata 分区</strong></h3><ul><li><strong>功能</strong>: 存储用户数据和应用程序数据，例如应用安装包、用户设置、下载文件等。</li><li><strong>特点</strong>: 该分区是可读写的，并且可以通过设备的恢复模式或出厂重置进行清空。</li></ul><h3 id="5-recovery-分区">5. <strong>recovery 分区</strong></h3><ul><li><strong>功能</strong>: 包含 Android 恢复模式，用于系统恢复、出厂重置或手动刷机。设备出现问题时，用户可以通过该分区进入恢复模式修复设备。</li><li><strong>特点</strong>: 该分区可以通过组合键进入，通常用于修复系统问题或手动更新固件。</li></ul><h3 id="6-cache-分区">6. <strong>cache 分区</strong></h3><ul><li><strong>功能</strong>: 存储系统和应用程序的临时缓存文件，特别是在 OTA 更新过程中用于存储下载的更新包。</li><li><strong>特点</strong>: 该分区不存储关键数据，用户可以清空而不会影响系统运行。</li></ul><h3 id="7-modem--radio-分区">7. <strong>modem / radio 分区</strong></h3><ul><li><strong>功能</strong>: 包含基带固件和无线通信相关的驱动程序，用于设备的蜂窝网络、Wi-Fi、蓝牙等功能。</li><li><strong>特点</strong>: 该分区通常与设备的硬件直接关联，更新系统时可能需要重新刷写此分区以支持新的通信协议或网络功能。</li></ul><h3 id="8-vbmeta-分区">8. <strong>vbmeta 分区</strong></h3><ul><li><strong>功能</strong>: 用于验证引导（Verified Boot），通过存储和检查设备的加密签名来确保系统的完整性，防止引导过程中加载未经授权的系统镜像或修改。</li><li><strong>特点</strong>: Android 11 中，<code>vbmeta</code> 分区进一步强化了设备安全性，确保设备的引导过程不会被恶意软件篡改。</li></ul><h3 id="9-dynamic-分区">9. <strong>dynamic 分区</strong></h3><ul><li><strong>功能</strong>: 动态分区是 Android 11 中的新特性，它允许多个逻辑分区共享物理存储。系统可以动态调整这些逻辑分区的大小，而无需对物理分区进行重新格式化。</li><li><strong>特点</strong>: 这种机制极大地提高了 OTA 更新的灵活性，并减少了对物理存储空间的浪费。</li></ul><h3 id="10-ab-分区机制">10. <strong>A/B 分区机制</strong></h3><ul><li><strong>概述</strong>: Android 11 继续支持无缝更新（Seamless Updates），通过 A/B 分区架构实现。设备拥有两套相同的系统分区（Slot A 和 Slot B），更新时系统会将更新应用到备用分区。更新完成后，设备重启并切换到新的分区。</li><li><strong>常见的 A/B 分区</strong>:<ul><li><code>boot_a</code> / <code>boot_b</code></li><li><code>system_a</code> / <code>system_b</code></li><li><code>vendor_a</code> / <code>vendor_b</code></li></ul></li><li><strong>特点</strong>: 这种机制确保了系统更新的安全性和稳定性，即使更新失败，设备仍然可以从未更新的分区启动。</li></ul><h3 id="11-为什么不使用-ext4-快照？">11. <strong>为什么不使用 ext4 快照？</strong></h3><p>Android 的无缝更新机制基于 A/B 分区架构，而不是依赖于 ext4 的快照功能。以下是它的工作原理：</p><ul><li><strong>双分区</strong>: 系统维护两套主要分区：<code>Slot A</code> 和 <code>Slot B</code>。在设备运行期间，系统在一个分区上工作，而更新则被下载并应用到备用分区。</li><li><strong>分区切换</strong>: 一旦更新完成，设备会重启并引导到更新后的分区。如果更新过程中出现问题，设备可以安全地回滚到原来的分区，避免系统变砖的风险。</li><li><strong>Verified Boot</strong>: 在系统启动前，通过 <code>vbmeta</code> 分区对更新的分区进行验证，确保分区的完整性和合法性。</li></ul><p><strong>ext4 文件系统的快照功能</strong>（例如通过 <code>e2fsprogs</code> 的 <code>e2image</code> 工具或 LVM 层次的快照）确实可以为数据备份或快速恢复提供帮助，但它并不适合 Android 的无缝更新需求，主要原因如下：</p><ol><li><strong>快照不是动态更新的最佳选择</strong>: 虽然快照功能可以保存文件系统的特定状态，但它在实际使用中无法提供像 A/B 分区机制那样无中断的更新体验。A/B 分区允许在用户使用设备的同时下载和安装更新，而无需暂停服务或立即重启。</li><li><strong>存储效率和安全性</strong>: Android 的 A/B 分区更新方式已经通过动态分区和其他机制优化了存储使用。而 ext4 快照会占用额外的磁盘空间，并且快照的增量更新可能导致复杂性和性能问题。</li><li><strong>快照回滚不适合系统级更新</strong>: 虽然快照适合文件级别的恢复，但系统更新涉及到核心系统组件，快照回滚可能不够稳定或安全。而 A/B 分区通过 Verified Boot 等机制确保系统更新的完整性和回滚的安全性。</li></ol><p>===========The End===========</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 九月 26, 2024</p><div class="post__share"></div></footer><nav class="pagination"><div class="pagination__title"><span>Read other posts</span></div><div class="pagination__buttons"><a href="https://blog.nasyes.cn/aosp-otade-ying-yongupdateengineliu-cheng-jie-du.html" class="btn previous" rel="prev" aria-label="[MISSING TRANSLATION]:  AOSP OTA包的应用：update_engine模块解读 "><span class="btn__icon">←</span> <span class="btn__text">AOSP OTA包的应用：update_engine模块解读</span> </a><a href="https://blog.nasyes.cn/guo-nei-qtying-yong-zui-duo-de-xing-ye-he-ling-yu.html" class="btn next" rel="next" aria-label="[MISSING TRANSLATION]:  国内Qt应用最多的行业和领域 "><span class="btn__text">国内Qt应用最多的行业和领域</span> <span class="btn__icon">→</span></a></div></nav></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><p>© 2024 Powered by Publii CMS :: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank" rel="noopener">Theme</a> ported by the <a href="https://getpublii.com/customization-service/" target="_blank" rel="noopener">Publii Team</a></p></div></div></footer></div><script defer="defer" src="https://blog.nasyes.cn/assets/js/scripts.min.js?v=74fad06980c30243d91d72c7c57fcdb8"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>