<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/">
    <title>HEIN&#x27;s Blog</title>
    <link href="https://blog.nasyes.cn/feed.xml" rel="self" />
    <link href="https://blog.nasyes.cn" />
    <updated>2024-12-03T14:34:46+08:00</updated>
    <author>
        <name>HEIN</name>
    </author>
    <id>https://blog.nasyes.cn</id>

    <entry>
        <title>[GPT]编译型语言和解释型语言的优缺点对比</title>
        <author>
            <name>HEIN</name>
        </author>
        <link href="https://blog.nasyes.cn/gptbian-yi-xing-yu-yan-he-jie-shi-xing-yu-yan-de-you-que-dian-dui-bi.html"/>
        <id>https://blog.nasyes.cn/gptbian-yi-xing-yu-yan-he-jie-shi-xing-yu-yan-de-you-que-dian-dui-bi.html</id>

        <updated>2024-12-03T14:17:31+08:00</updated>
            <summary>
                <![CDATA[
                    编译型语言和解释型语言各有优缺点，选择使用哪种语言通常取决于具体的应用场景和需求。以下是它们的优缺点对比： 如：C、C++、Go、Rust等。 如：Python、JavaScript、Ruby、PHP等。 在实际开发中，可以通过混合使用编译型语言和解释型语言，结合它们各自的优点，满足不同的需求。
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>编译型语言和解释型语言各有优缺点，选择使用哪种语言通常取决于具体的应用场景和需求。以下是它们的优缺点对比：</p><hr>
<h3 id="编译型语言"><strong>编译型语言</strong></h3>
<p>如：C、C++、Go、Rust等。</p><h4 id="优点"><strong>优点</strong></h4>
<ol>
<li><strong>性能优越</strong><br>编译型语言在编译时将代码直接翻译为机器代码，因此运行时无需再进行翻译，执行速度快，适合对性能要求较高的场景。  </li>
<li><strong>安全性较高</strong><br>在编译阶段会检查代码中的语法和类型错误，可以在程序运行前发现问题，提高代码质量和安全性。  </li>
<li><strong>部署简单</strong><br>编译后生成独立的可执行文件，无需安装额外的解释器或运行时环境，方便分发和部署。  </li>
<li><strong>优化空间大</strong><br>编译器可以对代码进行深度优化（如循环展开、内联函数等），进一步提升运行效率。</li>
</ol>
<h4 id="缺点"><strong>缺点</strong></h4>
<ol>
<li><strong>编译耗时</strong><br>编译需要一定时间，尤其对于大型项目，可能会影响开发效率。  </li>
<li><strong>调试不便</strong><br>有些编译型语言生成的错误信息可能难以理解，调试时需要借助工具，如调试器和日志。  </li>
<li><strong>平台相关性强</strong><br>编译后的程序可能与特定平台绑定，需要针对不同平台进行交叉编译。</li>
</ol>
<hr>
<h3 id="解释型语言"><strong>解释型语言</strong></h3>
<p>如：Python、JavaScript、Ruby、PHP等。</p><h4 id="优点-1"><strong>优点</strong></h4>
<ol>
<li><strong>开发效率高</strong><br>无需编译，代码可以直接运行，适合快速迭代开发。  </li>
<li><strong>跨平台性强</strong><br>只要有相应的解释器，代码可以直接运行在不同平台上，移植成本低。  </li>
<li><strong>灵活性高</strong><br>通常具有动态类型系统和丰富的标准库，编写脚本、处理文件或网络通信都非常方便。  </li>
<li><strong>调试友好</strong><br>因为是逐行解释运行，遇到问题时可以立即发现，调试相对容易。</li>
</ol>
<h4 id="缺点-1"><strong>缺点</strong></h4>
<ol>
<li><strong>性能较低</strong><br>因为代码在运行时需要逐行翻译为机器代码，性能不如编译型语言。  </li>
<li><strong>运行依赖环境</strong><br>必须安装解释器或运行时环境，可能增加系统的复杂性。  </li>
<li><strong>类型安全性较低</strong><br>动态类型可能导致一些运行时错误难以发现，增加了维护难度。</li>
</ol>
<hr>
<h3 id="总结"><strong>总结</strong></h3>
<ul>
<li>如果需求重点是<strong>性能</strong>、<strong>稳定性</strong>，如操作系统、游戏引擎、数据库系统等，适合选择编译型语言。  </li>
<li>如果需求重点是<strong>快速开发</strong>、<strong>跨平台</strong>或需要<strong>动态交互</strong>，如数据分析、Web开发、脚本编写等，适合选择解释型语言。</li>
</ul>
<p>在实际开发中，可以通过<strong>混合使用</strong>编译型语言和解释型语言，结合它们各自的优点，满足不同的需求。</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>[GPT]Qt、flutter、tauri三种跨平台开发框架的横向对比</title>
        <author>
            <name>HEIN</name>
        </author>
        <link href="https://blog.nasyes.cn/gptqtfluttertaurisan-zhong-kua-ping-tai-kai-fa-kuang-jia-de-heng-xiang-dui-bi.html"/>
        <id>https://blog.nasyes.cn/gptqtfluttertaurisan-zhong-kua-ping-tai-kai-fa-kuang-jia-de-heng-xiang-dui-bi.html</id>

        <updated>2024-11-28T15:57:35+08:00</updated>
            <summary>
                <![CDATA[
                    以下是 Qt、Flutter 和 Tauri 三种跨平台开发框架的详细对比，基于操作系统支持、开发语言、性能、稳定性、包体大小等多个维度，数据尽可能基于2023年及以后的最新资料。 通过综合比较，开发者可以根据具体项目需求选择合适的框架。如果追求成熟的生态和高性能，推荐 Qt；如果关注 UI 表现和开发效率，推荐 Flutter；如果需求偏轻量和现代化技术，推荐 Tauri。
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>以下是 <strong>Qt</strong>、<strong>Flutter</strong> 和 <strong>Tauri</strong> 三种跨平台开发框架的详细对比，基于操作系统支持、开发语言、性能、稳定性、包体大小等多个维度，数据尽可能基于2023年及以后的最新资料。</p><hr>
<h3 id="1-操作系统支持与图形框架"><strong>1. 操作系统支持与图形框架</strong></h3>
<table>
<thead>
<tr>
<th><strong>框架</strong></th>
<th><strong>支持平台</strong></th>
<th><strong>图形框架</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Qt</strong></td>
<td>Windows、macOS、Linux、Android、iOS、嵌入式（RTOS）</td>
<td>基于 OpenGL/Metal/Vulkan 的 Qt Quick 和 QWidget</td>
</tr>
<tr>
<td><strong>Flutter</strong></td>
<td>Windows、macOS、Linux、Android、iOS、Web</td>
<td>Skia 图形引擎</td>
</tr>
<tr>
<td><strong>Tauri</strong></td>
<td>Windows、macOS、Linux、Android、iOS</td>
<td>系统自带 WebView（如 macOS 的 WebKit，Windows 的 Edge WebView2）</td>
</tr>
</tbody></table>
<ul>
<li><strong>Qt</strong>: 强调全面性，特别是嵌入式设备的支持，适用于高性能桌面应用和工业领域。</li>
<li><strong>Flutter</strong>: 强调 UI 的一致性，使用 Skia 绘图引擎直接渲染，适合移动和桌面应用。</li>
<li><strong>Tauri</strong>: 使用系统 WebView，因此占用资源更少，但图形表现依赖于平台原生能力。</li>
</ul>
<hr>
<h3 id="2-开发语言"><strong>2. 开发语言</strong></h3>
<table>
<thead>
<tr>
<th><strong>框架</strong></th>
<th><strong>开发语言</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Qt</strong></td>
<td>C++/QML</td>
<td>C++ 提供高性能，QML 简化 UI 开发</td>
</tr>
<tr>
<td><strong>Flutter</strong></td>
<td>Dart</td>
<td>Dart 是专为 Flutter 设计，强调快速构建 UI</td>
</tr>
<tr>
<td><strong>Tauri</strong></td>
<td>Rust + HTML/CSS/JS</td>
<td>Rust 作为后端语言，前端使用 Web 技术</td>
</tr>
</tbody></table>
<ul>
<li><strong>Qt</strong>: 高性能语言和易用的声明式 UI 开发结合，适合复杂的应用。</li>
<li><strong>Flutter</strong>: Dart 是新兴语言，学习曲线较平缓。</li>
<li><strong>Tauri</strong>: Rust 的高安全性和性能吸引开发者，但学习曲线较陡。</li>
</ul>
<hr>
<h3 id="3-性能"><strong>3. 性能</strong></h3>
<table>
<thead>
<tr>
<th><strong>框架</strong></th>
<th><strong>性能特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Qt</strong></td>
<td>原生性能，适合实时性要求高的嵌入式应用和桌面应用。</td>
</tr>
<tr>
<td><strong>Flutter</strong></td>
<td>使用 Skia，接近原生的绘图性能，适合高频动画和跨平台一致性。</td>
</tr>
<tr>
<td><strong>Tauri</strong></td>
<td>应用轻量，启动速度快，但性能依赖 WebView 和前端实现质量。</td>
</tr>
</tbody></table>
<ul>
<li><strong>Qt</strong>: 性能最佳，适合工业和游戏场景。</li>
<li><strong>Flutter</strong>: 在移动端性能出色，但包体积较大。</li>
<li><strong>Tauri</strong>: 高效但需注意 WebView 的限制。</li>
</ul>
<hr>
<h3 id="4-稳定性"><strong>4. 稳定性</strong></h3>
<table>
<thead>
<tr>
<th><strong>框架</strong></th>
<th><strong>稳定性分析</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Qt</strong></td>
<td>成熟框架，稳定性高，适合长期项目。</td>
</tr>
<tr>
<td><strong>Flutter</strong></td>
<td>社区活跃，Google 支持，但较新特性可能不够稳定。</td>
</tr>
<tr>
<td><strong>Tauri</strong></td>
<td>Rust 的内存安全性带来更好的稳定性，但生态尚不成熟。</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-包体大小"><strong>5. 包体大小</strong></h3>
<table>
<thead>
<tr>
<th><strong>框架</strong></th>
<th><strong>包体大小特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Qt</strong></td>
<td>较大，需打包 Qt 库。</td>
</tr>
<tr>
<td><strong>Flutter</strong></td>
<td>较大，需包含 Flutter 引擎和 Skia。</td>
</tr>
<tr>
<td><strong>Tauri</strong></td>
<td>较小，仅依赖 WebView 和 Rust 后端。</td>
</tr>
</tbody></table>
<ul>
<li><strong>Tauri</strong> 在包体积上优势显著，适合需要轻量化的项目。</li>
</ul>
<hr>
<h3 id="6-优缺点总结"><strong>6. 优缺点总结</strong></h3>
<table>
<thead>
<tr>
<th><strong>框架</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Qt</strong></td>
<td>性能优越，生态丰富，适合工业级应用</td>
<td>学习成本高，商业版收费</td>
</tr>
<tr>
<td><strong>Flutter</strong></td>
<td>UI 一致性强，社区活跃</td>
<td>包体积较大，性能略逊于原生</td>
</tr>
<tr>
<td><strong>Tauri</strong></td>
<td>轻量高效，使用 Rust 提供安全性</td>
<td>Rust 学习曲线陡峭，生态尚不成熟</td>
</tr>
</tbody></table>
<hr>
<h3 id="7-适用场景"><strong>7. 适用场景</strong></h3>
<ul>
<li><strong>Qt</strong>: 工业级设备、复杂桌面应用。</li>
<li><strong>Flutter</strong>: 跨平台移动应用、高频动画界面。</li>
<li><strong>Tauri</strong>: 轻量级桌面和移动应用，优先考虑安全性和小体积需求。</li>
</ul>
<p>通过综合比较，开发者可以根据具体项目需求选择合适的框架。如果追求成熟的生态和高性能，推荐 <strong>Qt</strong>；如果关注 UI 表现和开发效率，推荐 <strong>Flutter</strong>；如果需求偏轻量和现代化技术，推荐 <strong>Tauri</strong>。</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>[GPT]Qt技术介绍大纲</title>
        <author>
            <name>HEIN</name>
        </author>
        <link href="https://blog.nasyes.cn/gptqtji-shu-jie-shao-da-gang.html"/>
        <id>https://blog.nasyes.cn/gptqtji-shu-jie-shao-da-gang.html</id>

        <updated>2024-11-13T11:22:54+08:00</updated>
            <summary>
                <![CDATA[
                    1. 封面 标题：Qt 技术介绍 副标题：Qt 框架的历史、优势、核心模块、应用场景、常用工具与未来发展 作者/公司信息 2. 目录 什么是Qt Qt的历史与演变 Qt的优势 Qt的核心模块及应用 Qt 在不同领域的应用 Qt 开发的常用工具和技术栈 Qt 的未来发展 总结 3. 什么是Qt Qt是一个跨平台的应用开发框架，由C++语言编写，提供了丰富的API和可视化开发工具。 支持多种平台：Windows、Linux、macOS、Android、iOS、嵌入式设备等，实现“一次编写，处处运行”。 Qt库是基于模块化结构设计的，开发者可以根据需求自由选择模块。&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h3 id="1-封面">1. <strong>封面</strong></h3>
<ul>
<li>标题：Qt 技术介绍</li>
<li>副标题：Qt 框架的历史、优势、核心模块、应用场景、常用工具与未来发展</li>
<li>作者/公司信息</li>
</ul>
<h3 id="2-目录">2. <strong>目录</strong></h3>
<ul>
<li>什么是Qt</li>
<li>Qt的历史与演变</li>
<li>Qt的优势</li>
<li>Qt的核心模块及应用</li>
<li>Qt 在不同领域的应用</li>
<li>Qt 开发的常用工具和技术栈</li>
<li>Qt 的未来发展</li>
<li>总结</li>
</ul>
<hr>
<h3 id="3-什么是qt">3. <strong>什么是Qt</strong></h3>
<ul>
<li>Qt是一个跨平台的应用开发框架，由C++语言编写，提供了丰富的API和可视化开发工具。</li>
<li>支持多种平台：Windows、Linux、macOS、Android、iOS、嵌入式设备等，实现“一次编写，处处运行”。</li>
<li>Qt库是基于模块化结构设计的，开发者可以根据需求自由选择模块。</li>
</ul>
<h3 id="4-qt的历史与演变">4. <strong>Qt的历史与演变</strong></h3>
<ul>
<li>1991年：Qt由Trolltech创立，最初用于Unix系统。</li>
<li>2008年：被诺基亚收购，扩展了移动端支持。</li>
<li>2012年：Digia收购Qt，继续推动跨平台开发。</li>
<li>2016年：The Qt Company成立，专注于Qt技术的商业化和社区发展。</li>
<li>发展至今，Qt已成为工业界、嵌入式设备、移动应用、桌面应用等多种场景的主要开发框架之一。</li>
</ul>
<h3 id="5-qt-的优势">5. <strong>Qt 的优势</strong></h3>
<ul>
<li><strong>跨平台性</strong>：支持多种操作系统，减少移植成本。</li>
<li><strong>灵活的UI设计</strong>：Qt Widgets和Qt Quick结合，使得开发现代UI更高效。</li>
<li><strong>高性能和稳定性</strong>：C++语言的高效底层性能，同时具有较少的内存占用。</li>
<li><strong>强大的社区和开源支持</strong>：大量的开源项目和支持文档，有助于解决开发问题。</li>
<li><strong>丰富的API和插件支持</strong>：支持多媒体、网络、数据库、图形渲染等功能，提升开发效率。</li>
</ul>
<h3 id="6-qt-核心模块概述">6. <strong>Qt 核心模块概述</strong></h3>
<ul>
<li>Qt以模块形式组织，模块的组合使得Qt适用于各种类型的应用开发。</li>
<li>核心模块包括Qt Core、Qt GUI、Qt Widgets、Qt Quick、Qt Multimedia、Qt Network等，满足不同的开发需求。</li>
</ul>
<h3 id="7-qt-core-模块">7. <strong>Qt Core 模块</strong></h3>
<ul>
<li><strong>概述</strong>：Qt Core是基础模块，提供数据结构、文件系统、事件循环、日期和时间等核心功能。</li>
<li><strong>数据结构支持</strong>：如QList、QHash、QSet等，为复杂数据处理提供高效支持。</li>
<li><strong>事件驱动模型</strong>：基于信号和槽机制，简化了异步处理，使得数据和UI更新更加方便。</li>
<li><strong>示例代码</strong>：<pre><code class="language-cpp">QObject::connect(sender, SIGNAL(signalName()), receiver, SLOT(slotName()));
</code></pre>
</li>
</ul>
<h3 id="8-qt-gui-与-widgets-模块">8. <strong>Qt GUI 与 Widgets 模块</strong></h3>
<ul>
<li><strong>Qt GUI</strong>：实现低级图形功能，如绘图、文本渲染、OpenGL支持，适用于高性能图形应用。</li>
<li><strong>Qt Widgets</strong>：提供传统桌面应用UI的经典组件，如按钮、标签、菜单等，适合传统桌面UI设计。</li>
<li><strong>高级UI特性</strong>：支持复杂的窗口管理、自定义绘图、样式定制等功能。</li>
<li><strong>应用示例</strong>：如创建图形化文件管理器、IDE、文本编辑器等。</li>
</ul>
<h3 id="9-qt-quick-与-qml-模块">9. <strong>Qt Quick 与 QML 模块</strong></h3>
<ul>
<li><strong>QML</strong>：QML是一种基于JavaScript的声明式语言，专注于动态和现代化UI设计。</li>
<li><strong>Qt Quick</strong>：结合QML提供强大的UI构建能力，支持动画、状态和过渡效果。</li>
<li><strong>动画效果</strong>：通过QML可以定义自然的UI交互动画，提高用户体验。</li>
<li><strong>动态响应式设计</strong>：通过绑定、属性和状态的变化，可以快速适配不同分辨率和设备。</li>
<li><strong>QML 示例代码</strong>：<pre><code class="language-qml">Rectangle {
    width: 200; height: 200
    color: &quot;blue&quot;
    MouseArea {
        anchors.fill: parent
        onClicked: parent.color = &quot;red&quot;
    }
}
</code></pre>
</li>
</ul>
<h3 id="10-qt-network-和-multimedia-模块">10. <strong>Qt Network 和 Multimedia 模块</strong></h3>
<ul>
<li><strong>Qt Network</strong>：提供TCP、UDP、HTTP、FTP等网络协议的支持，方便开发网络通信应用。</li>
<li><strong>高级特性</strong>：支持SSL加密、网络代理、HTTP/2等，保证安全性和高效性。</li>
<li><strong>Qt Multimedia</strong>：用于处理音频、视频、相机等多媒体数据，适合开发播放器、视频会议等多媒体应用。</li>
<li><strong>示例代码</strong>：<pre><code class="language-cpp">QMediaPlayer *player = new QMediaPlayer;
player-&gt;setMedia(QUrl(&quot;http://example.com/media.mp4&quot;));
player-&gt;play();
</code></pre>
</li>
</ul>
<h3 id="11-qt-的其他高级模块">11. <strong>Qt 的其他高级模块</strong></h3>
<ul>
<li><strong>Qt Charts</strong>：用于创建统计图表的模块，支持柱状图、饼图、折线图等。</li>
<li><strong>Qt 3D</strong>：提供3D图形和场景渲染，适合轻量级3D应用开发。</li>
<li><strong>Qt Sensors</strong>：访问移动设备传感器数据，如加速度计、陀螺仪、位置传感器等。</li>
<li><strong>Qt WebEngine</strong>：集成了Chromium浏览器内核，支持网页嵌入和Web应用开发。</li>
</ul>
<h3 id="12-qt-的应用领域">12. <strong>Qt 的应用领域</strong></h3>
<ul>
<li><strong>桌面应用开发</strong>：如开发图形化工具软件、桌面软件、IDE。</li>
<li><strong>嵌入式系统开发</strong>：汽车中控、智能家居控制面板、工业设备人机界面（HMI）。</li>
<li><strong>移动应用开发</strong>：支持Android和iOS的跨平台应用，适合快速迭代和原型设计。</li>
<li><strong>多媒体和通信应用</strong>：如视频会议、流媒体播放器、即时通讯工具。</li>
</ul>
<h3 id="13-qt在工业领域的应用">13. <strong>Qt在工业领域的应用</strong></h3>
<ul>
<li><strong>汽车领域</strong>：如汽车导航系统、信息娱乐系统、仪表盘UI。</li>
<li><strong>医疗设备</strong>：医疗成像设备界面、监测仪器的触控控制系统。</li>
<li><strong>智能家居</strong>：智能冰箱、智能空调、家居控制面板等。</li>
<li><strong>工业自动化</strong>：工厂操作界面、生产线监控、工业机器人控制等。</li>
</ul>
<h3 id="14-qt-在游戏开发的应用">14. <strong>Qt 在游戏开发的应用</strong></h3>
<ul>
<li>通过<strong>Qt Quick</strong>和<strong>Qt 3D</strong>开发轻量级游戏，支持2D和3D场景。</li>
<li>使用QML实现动态UI和流畅的动画效果，适合移动端的游戏开发。</li>
<li>结合物理引擎，可以模拟真实物理效果，增强游戏的趣味性和互动性。</li>
</ul>
<h3 id="15-qt-在多媒体应用中的应用">15. <strong>Qt 在多媒体应用中的应用</strong></h3>
<ul>
<li><strong>媒体播放器</strong>：使用Qt Multimedia实现音视频播放控制，支持多种格式。</li>
<li><strong>实时视频会议</strong>：结合Qt Network和Qt Multimedia开发视频通话、屏幕共享等功能。</li>
<li><strong>音频处理应用</strong>：通过音频输入输出、波形显示，实现音乐编辑器、录音软件等功能。</li>
</ul>
<h3 id="16-qt-的开发工具和生态">16. <strong>Qt 的开发工具和生态</strong></h3>
<ul>
<li><strong>Qt Creator</strong>：官方集成开发环境，提供代码编辑、调试、UI设计等功能。</li>
<li><strong>Qt Designer</strong>：UI可视化设计工具，可拖放组件，生成QML和C++代码。</li>
<li><strong>Qt Linguist</strong>：多语言支持工具，帮助开发本地化应用。</li>
<li><strong>QML Profiler</strong>：用于调试QML代码性能的工具，帮助优化UI性能。</li>
</ul>
<h3 id="17-qt-项目的管理和构建">17. <strong>Qt 项目的管理和构建</strong></h3>
<ul>
<li><strong>QMake</strong>：Qt的构建系统，帮助开发者配置和管理项目。</li>
<li><strong>CMake 支持</strong>：Qt5以后支持CMake，方便与其他C++项目集成。</li>
<li><strong>跨平台构建</strong>：Qt Creator可以轻松地为不同平台生成可执行文件。</li>
</ul>
<h3 id="18-qt的未来发展">18. <strong>Qt的未来发展</strong></h3>
<ul>
<li><strong>扩展跨平台支持</strong>：未来支持更多设备类型，如物联网和穿戴设备。</li>
<li><strong>提高渲染效率</strong>：通过新技术提升Qt在高帧率和高分辨率设备上的性能。</li>
<li><strong>集成AI与机器学习</strong>：结合AI接口，如TensorFlow Lite，实现智能交互。</li>
<li><strong>加强QML开发体验</strong>：提供更多QML组件，优化UI设计流程。</li>
</ul>
<h3 id="19-">19. **</h3>

            ]]>
        </content>
    </entry>
    <entry>
        <title>[GPT]国内Qt应用最多的行业和领域</title>
        <author>
            <name>HEIN</name>
        </author>
        <link href="https://blog.nasyes.cn/guo-nei-qtying-yong-zui-duo-de-xing-ye-he-ling-yu.html"/>
        <id>https://blog.nasyes.cn/guo-nei-qtying-yong-zui-duo-de-xing-ye-he-ling-yu.html</id>

        <updated>2024-09-27T13:54:47+08:00</updated>
            <summary>
                <![CDATA[
                    在国内，Qt 框架因其跨平台能力和强大的图形界面开发支持，在多个行业和领域得到广泛应用。以下为一些举例： 行业应用: 政府、教育、军队、企业内网操作系统。 行业应用: 制造业、自动化设备、能源管理、智能家居和物联网设备开发。 行业应用: 安防监控、视频编辑、流媒体处理、影视制作。 行业应用: 股票交易、金融服务、银行系统。 行业应用: 医疗设备制造、医院信息管理系统、健康监控设备。 行业应用: 汽车制造、车载信息系统、智能驾驶研发。 行业应用: 办公软件、在线教育、笔记管理系统。 行业应用: 安防监控、智能家居、视频监控系统。
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>在国内，<strong>Qt</strong> 框架因其跨平台能力和强大的图形界面开发支持，在多个行业和领域得到广泛应用。以下为一些举例：</p><h3 id="1-操作系统与桌面环境">1. <strong>操作系统与桌面环境</strong></h3>
<ul>
<li><strong>Qt</strong> 被广泛应用于中国自主研发的 <strong>Linux 操作系统</strong> 中，特别是在桌面环境开发上。例如：<ul>
<li><strong>优麒麟（Ubuntu Kylin）</strong>：基于 Ubuntu，采用 Qt 开发桌面环境。</li>
<li><strong>深度操作系统（Deepin）</strong>：深度桌面环境（DDE）是基于 Qt 开发的，具有简洁且易用的 UI。</li>
<li><strong>中标麒麟（Kylin OS）</strong>：也是中国国产 Linux 发行版，主要用于政府、军队和企业，部分使用 Qt 进行 UI 开发。</li>
</ul>
</li>
</ul>
<p>   <strong>行业应用</strong>: 政府、教育、军队、企业内网操作系统。</p><h3 id="2-工业自动化与物联网（iot）">2. <strong>工业自动化与物联网（IoT）</strong></h3>
<ul>
<li>Qt 在中国的 <strong>工业控制</strong> 和 <strong>物联网</strong> 领域得到了广泛应用。由于 Qt 的跨平台特性，能够为不同的硬件平台（如嵌入式设备、工业终端、触摸屏等）提供统一的图形界面开发。<ul>
<li><strong>工业人机界面（HMI）</strong>：如自动化设备、生产线、工业控制系统中常用 Qt 进行界面开发。</li>
<li><strong>物联网设备</strong>：Qt 在物联网中被用于创建智能设备的界面，从工业传感器到智能家居设备。</li>
</ul>
</li>
</ul>
<p>   <strong>行业应用</strong>: 制造业、自动化设备、能源管理、智能家居和物联网设备开发。</p><h3 id="3-图像与视频处理">3. <strong>图像与视频处理</strong></h3>
<ul>
<li>Qt 在中国的 <strong>图像处理</strong> 和 <strong>视频编辑</strong> 软件中得到广泛使用。由于 Qt 提供了强大的图形界面开发工具，可以方便地创建复杂的图像和视频处理应用。<ul>
<li><strong>视频监控软件</strong>：如海康威视、华为等安防企业常使用 Qt 来开发视频监控管理软件（如 iVMS-4200）。</li>
<li><strong>视频编辑工具</strong>：如 <strong>爱剪辑</strong> 等视频编辑软件使用 Qt 来构建视频处理和编辑的用户界面。</li>
</ul>
</li>
</ul>
<p>   <strong>行业应用</strong>: 安防监控、视频编辑、流媒体处理、影视制作。</p><h3 id="4-金融与证券">4. <strong>金融与证券</strong></h3>
<ul>
<li><strong>金融软件</strong> 和 <strong>证券交易平台</strong> 广泛使用 Qt 进行图形界面开发。其实时数据展示和复杂的交互功能非常适合 Qt 的高效开发工具集。<ul>
<li><strong>股票行情与交易软件</strong>：如东方财富通等，使用 Qt 进行行情展示、交易执行等功能的开发。</li>
<li><strong>银行系统终端</strong>：很多银行系统中的自助服务终端或客户端应用也使用 Qt 进行开发。</li>
</ul>
</li>
</ul>
<p>   <strong>行业应用</strong>: 股票交易、金融服务、银行系统。</p><h3 id="5-医疗设备">5. <strong>医疗设备</strong></h3>
<ul>
<li>在 <strong>医疗器械</strong> 领域，Qt 常用于开发医疗设备的用户界面和控制系统。例如，很多国产的医疗设备如超声仪器、CT 扫描仪等使用 Qt 来构建图形用户界面，方便医生进行操作和数据分析。<ul>
<li><strong>医疗仪器显示系统</strong>：如超声波仪、监护仪的界面控制和数据显示。</li>
<li><strong>健康管理设备</strong>：健康监测设备的用户界面开发。</li>
</ul>
</li>
</ul>
<p>   <strong>行业应用</strong>: 医疗设备制造、医院信息管理系统、健康监控设备。</p><h3 id="6-汽车电子与智能驾驶">6. <strong>汽车电子与智能驾驶</strong></h3>
<ul>
<li>Qt 在 <strong>汽车电子</strong> 和 <strong>智能驾驶</strong> 领域应用广泛，特别是在 <strong>车载信息娱乐系统</strong>（IVI）和 <strong>车载控制系统</strong> 中。Qt 的高性能图形引擎和触摸屏支持使其非常适合用于汽车的控制和显示界面。<ul>
<li><strong>车载信息娱乐系统</strong>：如导航、音频系统等。</li>
<li><strong>智能驾驶与自动驾驶显示系统</strong>：Qt 被用于汽车仪表盘、车载显示屏等设备。</li>
</ul>
</li>
</ul>
<p>   <strong>行业应用</strong>: 汽车制造、车载信息系统、智能驾驶研发。</p><h3 id="7-教育与办公">7. <strong>教育与办公</strong></h3>
<ul>
<li><strong>教育软件</strong> 和 <strong>办公工具</strong> 也广泛采用 Qt 进行开发。例如，金山软件的 <strong>WPS Office（Linux 版）</strong> 和网易有道的 <strong>有道云笔记</strong> 等常见办公工具的 Linux 版本都基于 Qt。<ul>
<li><strong>在线教育平台</strong>：如掌门教育、VIPKID 等部分教育平台的客户端界面基于 Qt 开发，支持实时互动教学。</li>
<li><strong>办公软件</strong>：如 WPS Office 提供跨平台的办公功能，特别是 Linux 平台上。</li>
</ul>
</li>
</ul>
<p>   <strong>行业应用</strong>: 办公软件、在线教育、笔记管理系统。</p><h3 id="8-安防与监控">8. <strong>安防与监控</strong></h3>
<ul>
<li>在 <strong>安防</strong> 领域，Qt 是视频监控管理系统和安防设备管理系统的重要开发框架。<ul>
<li><strong>视频监控系统</strong>：海康威视、大华等安防行业的巨头常用 Qt 开发监控设备的管理界面。</li>
<li><strong>智能家居安防设备</strong>：智能门锁、监控摄像头等家居安防设备的控制界面也常使用 Qt 进行开发。</li>
</ul>
</li>
</ul>
<p>   <strong>行业应用</strong>: 安防监控、智能家居、视频监控系统。</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Android系统分区构成和解析：以AOSP11为例</title>
        <author>
            <name>HEIN</name>
        </author>
        <link href="https://blog.nasyes.cn/android11xi-tong-fen-qu-jie-shao.html"/>
        <id>https://blog.nasyes.cn/android11xi-tong-fen-qu-jie-shao.html</id>

        <updated>2024-09-26T11:20:29+08:00</updated>
            <summary>
                <![CDATA[
                    在 Android 11 中，系统分区管理通过多种物理分区来实现设备的引导、系统操作、数据存储和无线通信等功能。Android 11 引入了增强的系统更新机制，如 A/B 分区 和 动态分区，以提高系统的更新效率和安全性。以下是 Android 11 中常见的物理分区介绍： Android 的无缝更新机制基于 A/B 分区架构，而不是依赖于 ext4 的快照功能。以下是它的工作原理： ext4 文件系统的快照功能（例如通过 e2fsprogs 的 e2image 工具或&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>在 Android 11 中，系统分区管理通过多种物理分区来实现设备的引导、系统操作、数据存储和无线通信等功能。Android 11 引入了增强的系统更新机制，如 <strong>A/B 分区</strong> 和 <strong>动态分区</strong>，以提高系统的更新效率和安全性。以下是 Android 11 中常见的物理分区介绍：</p><h3 id="1-boot-分区">1. <strong>boot 分区</strong></h3>
<ul>
<li><strong>功能</strong>: 包含启动引导程序和 Linux 内核，用于设备启动。它加载内核并启动 Android 系统。</li>
<li><strong>特点</strong>: 该分区包含了设备启动时的关键组件，通常是只读的，只有在系统更新或开发模式下才会被修改。</li>
</ul>
<h3 id="2-system-分区">2. <strong>system 分区</strong></h3>
<ul>
<li><strong>功能</strong>: 存储 Android 操作系统的核心组件和框架，包括系统应用程序、库文件、系统服务和设置等。</li>
<li><strong>特点</strong>: Android 11 引入了 <strong>动态分区</strong>（Dynamic Partition），允许系统分区的动态调整和重新划分，而无需对物理分区进行硬性划分。系统更新时，这个分区的大小可以灵活调整。</li>
</ul>
<h3 id="3-vendor-分区">3. <strong>vendor 分区</strong></h3>
<ul>
<li><strong>功能</strong>: 存储厂商提供的硬件驱动和设备定制代码。它允许设备制造商将特定的硬件抽象层（HAL）独立于系统更新，以支持不同硬件。</li>
<li><strong>特点</strong>: 随着 Android 系统的模块化，<code>vendor</code> 分区在 Android 11 中变得更为重要，确保不同设备之间的兼容性和稳定性。</li>
</ul>
<h3 id="4-userdata-分区">4. <strong>userdata 分区</strong></h3>
<ul>
<li><strong>功能</strong>: 存储用户数据和应用程序数据，例如应用安装包、用户设置、下载文件等。</li>
<li><strong>特点</strong>: 该分区是可读写的，并且可以通过设备的恢复模式或出厂重置进行清空。</li>
</ul>
<h3 id="5-recovery-分区">5. <strong>recovery 分区</strong></h3>
<ul>
<li><strong>功能</strong>: 包含 Android 恢复模式，用于系统恢复、出厂重置或手动刷机。设备出现问题时，用户可以通过该分区进入恢复模式修复设备。</li>
<li><strong>特点</strong>: 该分区可以通过组合键进入，通常用于修复系统问题或手动更新固件。</li>
</ul>
<h3 id="6-cache-分区">6. <strong>cache 分区</strong></h3>
<ul>
<li><strong>功能</strong>: 存储系统和应用程序的临时缓存文件，特别是在 OTA 更新过程中用于存储下载的更新包。</li>
<li><strong>特点</strong>: 该分区不存储关键数据，用户可以清空而不会影响系统运行。</li>
</ul>
<h3 id="7-modem--radio-分区">7. <strong>modem / radio 分区</strong></h3>
<ul>
<li><strong>功能</strong>: 包含基带固件和无线通信相关的驱动程序，用于设备的蜂窝网络、Wi-Fi、蓝牙等功能。</li>
<li><strong>特点</strong>: 该分区通常与设备的硬件直接关联，更新系统时可能需要重新刷写此分区以支持新的通信协议或网络功能。</li>
</ul>
<h3 id="8-vbmeta-分区">8. <strong>vbmeta 分区</strong></h3>
<ul>
<li><strong>功能</strong>: 用于验证引导（Verified Boot），通过存储和检查设备的加密签名来确保系统的完整性，防止引导过程中加载未经授权的系统镜像或修改。</li>
<li><strong>特点</strong>: Android 11 中，<code>vbmeta</code> 分区进一步强化了设备安全性，确保设备的引导过程不会被恶意软件篡改。</li>
</ul>
<h3 id="9-dynamic-分区">9. <strong>dynamic 分区</strong></h3>
<ul>
<li><strong>功能</strong>: 动态分区是 Android 11 中的新特性，它允许多个逻辑分区共享物理存储。系统可以动态调整这些逻辑分区的大小，而无需对物理分区进行重新格式化。</li>
<li><strong>特点</strong>: 这种机制极大地提高了 OTA 更新的灵活性，并减少了对物理存储空间的浪费。</li>
</ul>
<h3 id="10-ab-分区机制">10. <strong>A/B 分区机制</strong></h3>
<ul>
<li><strong>概述</strong>: Android 11 继续支持无缝更新（Seamless Updates），通过 A/B 分区架构实现。设备拥有两套相同的系统分区（Slot A 和 Slot B），更新时系统会将更新应用到备用分区。更新完成后，设备重启并切换到新的分区。</li>
<li><strong>常见的 A/B 分区</strong>:<ul>
<li><code>boot_a</code> / <code>boot_b</code></li>
<li><code>system_a</code> / <code>system_b</code></li>
<li><code>vendor_a</code> / <code>vendor_b</code></li>
</ul>
</li>
<li><strong>特点</strong>: 这种机制确保了系统更新的安全性和稳定性，即使更新失败，设备仍然可以从未更新的分区启动。</li>
</ul>
<h3 id="11-为什么不使用-ext4-快照？">11. <strong>为什么不使用 ext4 快照？</strong></h3>
<p>Android 的无缝更新机制基于 A/B 分区架构，而不是依赖于 ext4 的快照功能。以下是它的工作原理：</p><ul>
<li><strong>双分区</strong>: 系统维护两套主要分区：<code>Slot A</code> 和 <code>Slot B</code>。在设备运行期间，系统在一个分区上工作，而更新则被下载并应用到备用分区。</li>
<li><strong>分区切换</strong>: 一旦更新完成，设备会重启并引导到更新后的分区。如果更新过程中出现问题，设备可以安全地回滚到原来的分区，避免系统变砖的风险。</li>
<li><strong>Verified Boot</strong>: 在系统启动前，通过 <code>vbmeta</code> 分区对更新的分区进行验证，确保分区的完整性和合法性。</li>
</ul>
<p><strong>ext4 文件系统的快照功能</strong>（例如通过 <code>e2fsprogs</code> 的 <code>e2image</code> 工具或 LVM 层次的快照）确实可以为数据备份或快速恢复提供帮助，但它并不适合 Android 的无缝更新需求，主要原因如下：</p><ol>
<li><strong>快照不是动态更新的最佳选择</strong>: 虽然快照功能可以保存文件系统的特定状态，但它在实际使用中无法提供像 A/B 分区机制那样无中断的更新体验。A/B 分区允许在用户使用设备的同时下载和安装更新，而无需暂停服务或立即重启。</li>
<li><strong>存储效率和安全性</strong>: Android 的 A/B 分区更新方式已经通过动态分区和其他机制优化了存储使用。而 ext4 快照会占用额外的磁盘空间，并且快照的增量更新可能导致复杂性和性能问题。</li>
<li><strong>快照回滚不适合系统级更新</strong>: 虽然快照适合文件级别的恢复，但系统更新涉及到核心系统组件，快照回滚可能不够稳定或安全。而 A/B 分区通过 Verified Boot 等机制确保系统更新的完整性和回滚的安全性。</li>
</ol>
<p>===========The End===========</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>AOSP OTA包的应用：update_engine模块解读</title>
        <author>
            <name>HEIN</name>
        </author>
        <link href="https://blog.nasyes.cn/aosp-otade-ying-yongupdateengineliu-cheng-jie-du.html"/>
        <id>https://blog.nasyes.cn/aosp-otade-ying-yongupdateengineliu-cheng-jie-du.html</id>

        <updated>2024-09-23T17:08:50+08:00</updated>
            <summary>
                <![CDATA[
                    本文旨在详细介绍 Android 11 的 update_engine 模块，包括更新流程、代码分析、增量更新技术及其对外部库的依赖。 update_engine 是 Android 系统负责 OTA 更新的核心模块，尤其适用于 A/B 分区机制。它在后台应用更新，确保设备无缝更新，且在更新失败时自动回滚到稳定版本。 操作主体：SystemUpdateManager、DownloadManager 系统更新的检查和下载是由 APP 层负责的，通常通过 Google Play 服务或定制的 OTA 服务器。 检查更新： SystemUpdateManager&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>本文旨在详细介绍 Android 11 的 <code>update_engine</code> 模块，包括更新流程、代码分析、增量更新技术及其对外部库的依赖。</p><hr>
<h3 id="一、update_engine-简介">一、<code>update_engine</code> 简介</h3>
<p><code>update_engine</code> 是 Android 系统负责 OTA 更新的核心模块，尤其适用于 A/B 分区机制。它在后台应用更新，确保设备无缝更新，且在更新失败时自动回滚到稳定版本。</p><hr>
<h3 id="二、更新流程及代码分析">二、更新流程及代码分析</h3>
<h4 id="1-系统更新检查与下载（app-层）">1. <strong>系统更新检查与下载</strong>（APP 层）</h4>
<ul>
<li><p><strong>操作主体</strong>：<code>SystemUpdateManager</code>、<code>DownloadManager</code></p><p>系统更新的检查和下载是由 APP 层负责的，通常通过 Google Play 服务或定制的 OTA 服务器。</p><ul>
<li><p><strong>检查更新</strong>：</p><pre><code class="language-java">SystemUpdateManager systemUpdateManager = new SystemUpdateManager();
boolean isUpdateAvailable = systemUpdateManager.isUpdateAvailable();
</code></pre>
<p>通过 <code>SystemUpdateManager</code> 与后台交互，检查是否有新的 OTA 更新可用。</p></li>
<li><p><strong>下载更新</strong>：
使用 <code>DownloadManager</code> 或自定义组件下载更新包。当下载完成后，系统会通知 <code>update_engine</code> 开始更新。</p></li>
</ul>
</li>
</ul>
<h4 id="2-验证与应用更新包（update_engine）">2. <strong>验证与应用更新包</strong>（<code>update_engine</code>）</h4>
<ul>
<li><p><strong>验证更新包</strong>：
下载完成的更新包交给 <code>update_engine</code> 进行完整性验证。<code>PayloadVerifier</code> 使用 openssl 验证 <code>payload.bin</code> 文件签名，确保更新包未被篡改。</p><ul>
<li><strong>关键代码片段</strong>：<pre><code class="language-cpp">bool PayloadVerifier::VerifyPayload(const std::string&amp; payload_path) {
    // 使用 openssl 进行签名验证
    if (!openssl_verify(payload_path)) {
        LOG(ERROR) &lt;&lt; &quot;Payload verification failed.&quot;;
        return false;
    }
    return true;
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>应用更新包</strong>：
<code>PayloadProcessor</code> 负责将下载好的更新包应用到非活动分区（如 <code>slot B</code>）。该模块解析 <code>payload</code> 文件，提取出增量更新信息并应用差异。</p><ul>
<li><strong>块级差异处理</strong>：<pre><code class="language-cpp">bool PayloadProcessor::ApplyUpdate(const std::string&amp; payload) {
    // 处理块级差异
    for (const auto&amp; operation : operations) {
        if (!ApplyBlockOperation(operation)) {
            LOG(ERROR) &lt;&lt; &quot;Failed to apply block operation.&quot;;
            return false;
        }
    }
    return true;
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-分区切换与重启">3. <strong>分区切换与重启</strong></h4>
<ul>
<li><p><strong>分区管理</strong>：
更新包应用完成后，<code>update_engine</code> 通过 <code>BootControlInterface</code> 切换分区，让系统在下次启动时从更新后的分区启动。</p><ul>
<li><strong>关键代码</strong>：<pre><code class="language-cpp">bool BootControlInterface::SetActiveSlot(int slot) {
    // 切换到指定的 slot
    return SetBootSlot(slot);
}
</code></pre>
</li>
</ul>
</li>
<li><p><strong>重启与验证</strong>：
系统重启后，从新分区启动。若启动成功，<code>update_engine</code> 标记更新为成功；如果启动失败，系统自动回滚到旧分区。</p></li>
</ul>
<h4 id="4-更新流程图">4. <strong>更新流程图</strong></h4>
<pre><code class="language-plaintext">1. APP 层检查更新 ——&gt; 2. 下载 OTA 包 ——&gt; 3. 交由 update_engine
   |
   V
4. 验证 OTA 包 ——&gt; 5. 应用更新包 ——&gt; 6. 切换分区 ——&gt; 7. 重启
   |                    |
   V                    V
8. 成功启动       失败回滚到旧分区
</code></pre>
<hr>
<h3 id="三、增量更新详细介绍">三、增量更新详细介绍</h3>
<p>在 Android 中，增量更新主要有两种方式：<strong>文件增量更新</strong>和<strong>块增量更新</strong>。</p><ol>
<li><p><strong>文件增量更新</strong><br>文件增量更新基于文件的元数据和内容进行比较。它会根据更新前后文件的内容差异，生成用于更新的文件差异包。这种方式的优势在于更新包的大小相对较小，因为只需要传输变化的文件部分。</p><p><strong>优点</strong>：</p><ul>
<li>更细粒度地控制文件内容。</li>
<li>更新包体积相对较小。</li>
</ul>
<p><strong>缺点</strong>：</p><ul>
<li>如果文件变化较大或文件系统发生变化，效果不如块级增量更新。</li>
</ul>
</li>
<li><p><strong>块级增量更新</strong><br>块级更新是基于存储设备上的分区块对比生成的。这种方法按块进行数据比较，而不仅仅是文件。即使文件没有显著变化，如果底层存储块发生了变动（如文件元数据或文件系统元数据发生变化），也会触发块级更新。</p><p><strong>优点</strong>：</p><ul>
<li>可以处理文件系统和元数据的变化。</li>
<li>更高效地处理大范围的数据变化。</li>
</ul>
<p><strong>缺点</strong>：</p><ul>
<li>更新包可能比文件级更新略大。</li>
</ul>
</li>
<li><p><strong>增量更新过程</strong>：
增量更新包通常由旧版本和新版本之间的差异生成。<code>update_engine</code> 负责将这些差异应用到非活动分区。无论是文件增量还是块增量，系统都会确保更新包应用后，设备能够在更新的分区上正常启动。</p></li>
</ol>
<hr>
<h3 id="四、增量更新示例流程">四、增量更新示例流程</h3>
<ol>
<li><p><strong>启动增量更新</strong>：
设备下载增量更新包后，<code>update_engine</code> 会调用 <code>PayloadProcessor</code> 来解压并应用增量更新。</p></li>
<li><p><strong>检查分区数据</strong>：
如果是文件级增量更新，系统会检查目标分区上的文件，生成更新前后的文件差异。
如果是块级增量更新，<code>PayloadProcessor</code> 会直接按块比较分区数据，并将差异应用到新的分区。</p></li>
<li><p><strong>应用差异包</strong>：
通过差异比较生成的差异包会被应用到目标分区（如 <code>slot B</code>）。这意味着 <code>slot A</code> 仍然保持当前状态，直到更新成功为止。</p></li>
<li><p><strong>切换分区</strong>：
更新完成后，设备重启并启动到已更新的分区（如 <code>slot B</code>）。此时，<code>slot A</code> 保持原始状态，以便在更新失败时进行回滚。</p></li>
<li><p><strong>验证启动和标记成功</strong>：
如果设备在新分区上成功启动，<code>update_engine</code> 将更新标记为成功。否则，设备会自动回滚到旧分区，并恢复到原始状态。</p></li>
</ol>
<hr>
<h3 id="五、外部库依赖">五、外部库依赖</h3>
<p><code>update_engine</code> 依赖于以下外部库来实现 OTA 更新功能：</p><ol>
<li><strong>libchrome</strong>：提供日志记录、线程和调度功能，帮助开发者调试和监控更新过程。</li>
<li><strong>libcurl</strong>：虽然 <code>update_engine</code> 本身不负责下载，但通过 libcurl 在某些定制场景下实现更新包的获取。</li>
<li><strong>libprotobuf</strong>：用于解析 <code>payload.bin</code> 文件中包含的 Protocol Buffers 元数据和更新信息。</li>
<li><strong>openssl</strong>：用于加密验证，确保下载的更新包未经篡改。</li>
</ol>
<hr>
<h3 id="六、调试与日志分析">六、调试与日志分析</h3>
<p><code>update_engine</code> 生成的日志提供详细的更新过程信息。可以通过以下命令查看：</p><pre><code class="language-bash">adb logcat | grep update_engine
</code></pre>
<p>常见的调试日志信息包括：</p><ul>
<li>更新包验证结果</li>
<li>分区写入进度</li>
<li>分区切换结果</li>
</ul>
<hr>
<h3 id="七、代码结构">七、代码结构</h3>
<h4 id="1-代码结构概览">1. 代码结构概览</h4>
<p><code>update_engine</code> 项目通常位于 AOSP 源代码的 <code>system/update_engine/</code> 目录下，主要负责管理 Android 系统的 OTA（Over-the-Air）更新。它实现了 Android 的无缝更新机制（A/B 分区更新），其中包括后台下载、系统更新和分区切换等功能。</p><p>以下是 <code>update_engine</code> 的代码结构：</p><pre><code>system/update_engine/
│
├── aosp/                      // AOSP 特定代码
├── client/                    // 客户端与 update_engine 的通信接口
├── common/                    // 跨平台的公共代码
├── cros/                      // ChromeOS 特定代码
├── daemon/                    // 守护进程和服务
├── hw/                        // 硬件特定的实现
├── libpayload_consumer/        // 处理更新负载的库
├── payload_generator/         // 生成 OTA 更新负载
├── scripts/                   // 构建与测试脚本
├── tests/                     // 单元测试代码
├── tools/                     // 各类工具
└── update_metadata.proto      // 更新元数据定义
</code></pre>
<h4 id="2-关键模块详解">2. 关键模块详解</h4>
<h5 id="21-aosp（aosp-特定代码）">2.1 <code>aosp/</code>（AOSP 特定代码）</h5>
<p>该目录包含 AOSP 相关的自定义实现，可能包括与其他 Android 系统组件集成的特定逻辑。它处理了 AOSP 中特定平台或系统的更新逻辑。</p><h5 id="22-client（客户端接口）">2.2 <code>client/</code>（客户端接口）</h5>
<p><code>client/</code> 目录下包含与 <code>update_engine</code> 守护进程进行通信的客户端接口。客户端用于发起更新请求和接收更新状态。</p><ul>
<li><code>update_engine_client.cc</code>：主要实现了与 <code>update_engine</code> 守护进程的通信逻辑，使用 D-Bus 进行消息传递。</li>
</ul>
<h5 id="23-common（通用模块）">2.3 <code>common/</code>（通用模块）</h5>
<p>这个目录下的代码是跨平台的公共代码，可能在 Android 和其他平台（如 ChromeOS）共享使用：</p><ul>
<li><code>utils.cc</code>：常用的工具类函数，包含日志、时间管理等通用功能。</li>
<li><code>metrics_reporter.cc</code>：用于记录并汇报更新过程中产生的性能和使用指标。</li>
</ul>
<h5 id="24-daemon（守护进程）">2.4 <code>daemon/</code>（守护进程）</h5>
<p><code>daemon/</code> 模块实现了 <code>update_engine</code> 的守护进程，它在后台持续运行，负责更新流程的主要逻辑。关键文件有：</p><ul>
<li><code>update_engine_daemon.cc</code>：守护进程的核心文件，初始化和启动 <code>update_engine</code>，并处理系统更新的主要操作。</li>
<li><code>service.cc</code>：实现了通过 D-Bus 提供服务的功能，处理外部的更新请求并与客户端交互。</li>
</ul>
<h5 id="25-libpayload_consumer（负载处理库）">2.5 <code>libpayload_consumer/</code>（负载处理库）</h5>
<p>这个模块负责处理更新包（payload），它会解析下载的更新负载，并将其应用到备用分区中。</p><ul>
<li><code>payload_processor.cc</code>：负责解析和处理增量或全量更新负载，并将其写入目标系统分区（通常是备用分区）。</li>
</ul>
<h5 id="26-payload_generator（更新负载生成器）">2.6 <code>payload_generator/</code>（更新负载生成器）</h5>
<p><code>payload_generator/</code> 负责生成 OTA 更新负载，通常由系统构建工具使用。这个模块包括增量更新负载的生成逻辑：</p><ul>
<li><code>delta_diff_generator.cc</code>：实现增量更新的生成，通过比较不同版本的文件系统生成更新所需的差异数据。</li>
</ul>
<h5 id="27-hw（硬件特定代码）">2.7 <code>hw/</code>（硬件特定代码）</h5>
<p>这个目录包含与特定硬件平台相关的实现。不同硬件可能需要特定的更新策略和驱动支持。</p><h5 id="28-scripts（脚本）">2.8 <code>scripts/</code>（脚本）</h5>
<p><code>scripts/</code> 目录包含了一些辅助脚本，用于自动化构建、部署、测试等任务。</p><h5 id="29-tests（测试）">2.9 <code>tests/</code>（测试）</h5>
<p>该目录包含了 <code>update_engine</code> 的单元测试和集成测试代码。确保各个模块在不同条件下都能正常工作。</p><h5 id="210-tools（工具）">2.10 <code>tools/</code>（工具）</h5>
<p>工具目录下包含一些调试和诊断工具，用于开发者在调试 OTA 更新功能时使用。</p><hr>
<p>Android 11 的 OTA 更新流程将更新包的下载与应用分离。APP 层负责检查和下载更新，<code>update_engine</code> 则专注于更新包的验证、应用和分区管理。增量更新技术的引入有效减少了更新包的大小，使得系统更新更加高效。</p><p>参考资料：
<a href="https://source.android.com/docs/core/ota">https://source.android.com/docs/core/ota</a>
<a href="https://blog.csdn.net/yang_mao_shan/category_12373702.html">https://blog.csdn.net/yang_mao_shan/category_12373702.html</a></p><p>===========The End===========</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>AOSP OTA包的制作：ota_from_target_files 的详细介绍</title>
        <author>
            <name>HEIN</name>
        </author>
        <link href="https://blog.nasyes.cn/aosp-otabao-de-zhi-zuoota_from_target_files-de-xiang-xi-jie-shao.html"/>
        <id>https://blog.nasyes.cn/aosp-otabao-de-zhi-zuoota_from_target_files-de-xiang-xi-jie-shao.html</id>

        <updated>2024-09-23T15:43:23+08:00</updated>
            <summary>
                <![CDATA[
                    ota_from_target_files 是 Android 构建系统中的一个脚本，用于从生成的 target_files.zip 包中创建 OTA（Over-The-Air）更新包。该工具在 Android 固件更新和设备维护过程中非常关键，通常与 AOSP 编译过程一起使用。 ota_from_target_files 是 Android 的 releasetools 脚本之一，它的作用是从包含系统镜像、内核、启动映像、分区表等内容的 target_files.zip 中生成一个完整的 OTA 更新包（.zip 文件）。生成的 OTA 包可以用于通过 adb&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p><code>ota_from_target_files</code> 是 Android 构建系统中的一个脚本，用于从生成的 <code>target_files.zip</code> 包中创建 OTA（Over-The-Air）更新包。该工具在 Android 固件更新和设备维护过程中非常关键，通常与 AOSP 编译过程一起使用。</p><h3 id="1-什么是-ota_from_target_files">1. 什么是 <code>ota_from_target_files</code></h3>
<p><code>ota_from_target_files</code> 是 Android 的 <code>releasetools</code> 脚本之一，它的作用是从包含系统镜像、内核、启动映像、分区表等内容的 <code>target_files.zip</code> 中生成一个完整的 OTA 更新包（<code>.zip</code> 文件）。生成的 OTA 包可以用于通过 <code>adb sideload</code> 或者直接通过系统的 OTA 机制进行升级。<br></p><figure class="post__image"><img loading="lazy" src="https://blog.nasyes.cn/media/posts/6/releasetools-3.jpg" alt="AOSP中的releasetools" width="1268" height="673"  sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/6/responsive/releasetools-3-xs.jpg 300w ,https://blog.nasyes.cn/media/posts/6/responsive/releasetools-3-sm.jpg 480w ,https://blog.nasyes.cn/media/posts/6/responsive/releasetools-3-md.jpg 768w ,https://blog.nasyes.cn/media/posts/6/responsive/releasetools-3-lg.jpg 1024w"></figure><h3 id="2-使用场景">2. 使用场景</h3>
<ul>
<li><strong>完整 OTA 包</strong>: 提供整个系统的更新。</li>
<li><strong>增量 OTA 包</strong>: 提供基于之前版本的增量更新包，从而减少更新包的大小。</li>
</ul>
<h3 id="3-ota_from_target_files-的主要参数">3. <code>ota_from_target_files</code> 的主要参数</h3>
<p>运行 <code>ota_from_target_files</code> 命令时，你可以指定多个选项和参数来控制输出的 OTA 包内容和格式。以下是一些常用的选项：</p><ul>
<li><code>--block</code>: 强制生成基于块的 OTA 包，而不是文件级别的更新。这种方式更适合现代设备，因为它更快且更安全。</li>
<li><code>--incremental_from=&lt;old_target_files.zip&gt;</code>: 指定增量更新的起始版本（即之前的系统版本），生成一个增量 OTA 包。增量 OTA 包只包含相对于旧版本的变化，从而使更新包更小。</li>
<li><code>--full_radio</code>: OTA 包中包括完整的 <code>radio.img</code> 文件，而不是增量。</li>
<li><code>--full_bootloader</code>: OTA 包中包括完整的 <code>bootloader.img</code> 文件，而不是增量。</li>
<li><code>--wipe_user_data</code>: 生成的 OTA 包会在更新时清除用户数据。</li>
<li><code>--downgrade</code>: 允许 OTA 包支持系统降级，这对于将设备恢复到早期版本时有用。</li>
</ul>
<h3 id="4-基本使用示例">4. 基本使用示例</h3>
<h4 id="41-创建完整-ota-包">4.1 创建完整 OTA 包</h4>
<p>完整 OTA 包会包含系统的全部内容，适用于首次安装或者大版本更新。</p><pre><code class="language-bash">python3 build/tools/releasetools/ota_from_target_files -v \
    out/target/product/&lt;device&gt;/obj/PACKAGING/target_files_intermediates/&lt;device&gt;-target_files-*.zip \
    out/target/product/&lt;device&gt;/ota_update_full.zip
</code></pre>
<ul>
<li><code>&lt;device&gt;</code>: 设备的代码名。</li>
<li><code>out/target/product/&lt;device&gt;/obj/PACKAGING/target_files_intermediates/&lt;device&gt;-target_files-*.zip</code>: 这是已经通过 <code>make target-files-package</code> 生成的目标文件包。</li>
<li><code>out/target/product/&lt;device&gt;/ota_update_full.zip</code>: 生成的完整 OTA 更新包。</li>
</ul>
<figure class="post__image"><img loading="lazy" src="https://blog.nasyes.cn/media/posts/6/ota_files.jpg" alt="ota_files" width="1392" height="1088"  sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/6/responsive/ota_files-xs.jpg 300w ,https://blog.nasyes.cn/media/posts/6/responsive/ota_files-sm.jpg 480w ,https://blog.nasyes.cn/media/posts/6/responsive/ota_files-md.jpg 768w ,https://blog.nasyes.cn/media/posts/6/responsive/ota_files-lg.jpg 1024w"></figure><h4 id="42-创建增量-ota-包">4.2 创建增量 OTA 包</h4>
<p>增量 OTA 包包含的是相对于旧版本的差异部分，适合系统的更新和小版本升级。</p><pre><code class="language-bash">python3 build/tools/releasetools/ota_from_target_files -v \
    --incremental_from=out/target/product/&lt;device&gt;/obj/PACKAGING/target_files_intermediates/&lt;device&gt;-old_target_files-*.zip \
    out/target/product/&lt;device&gt;/obj/PACKAGING/target_files_intermediates/&lt;device&gt;-target_files-*.zip \
    out/target/product/&lt;device&gt;/ota_update_incremental.zip
</code></pre>
<ul>
<li><code>--incremental_from</code>: 指定旧版本的 <code>target_files.zip</code>，用来生成增量 OTA 包。</li>
<li><code>out/target/product/&lt;device&gt;/ota_update_incremental.zip</code>: 生成的增量 OTA 更新包。</li>
</ul>
<h4 id="43-基于块的-ota-包">4.3 基于块的 OTA 包</h4>
<p>使用 <code>--block</code> 选项生成基于块的 OTA 包，这种更新方式更直接，适合现代 Android 设备。</p><pre><code class="language-bash">python3 build/tools/releasetools/ota_from_target_files -v --block \
    out/target/product/&lt;device&gt;/obj/PACKAGING/target_files_intermediates/&lt;device&gt;-target_files-*.zip \
    out/target/product/&lt;device&gt;/ota_update_block.zip
</code></pre>
<h3 id="5-解压和检查-target_fileszip">5. 解压和检查 <code>target_files.zip</code></h3>
<p>在使用 <code>ota_from_target_files</code> 之前，你可能需要检查 <code>target_files.zip</code> 包的内容。你可以通过解压缩来查看其结构：</p><pre><code class="language-bash">unzip out/target/product/&lt;device&gt;/obj/PACKAGING/target_files_intermediates/&lt;device&gt;-target_files-*.zip -d /tmp/target_files
</code></pre>
<p>解压缩后，<code>target_files.zip</code> 的目录结构通常如下：</p><pre><code>META/
BOOT/
RECOVERY/
SYSTEM/
VENDOR/
RADIO/
</code></pre>
<ul>
<li><code>META/</code>: 包含签名、更新脚本、<code>misc_info.txt</code> 等。</li>
<li><code>BOOT/</code>: 包含 <code>boot.img</code>。</li>
<li><code>RECOVERY/</code>: 包含 <code>recovery.img</code>。</li>
<li><code>SYSTEM/</code>: 系统分区内容。</li>
<li><code>VENDOR/</code>: 供应商分区内容。</li>
<li><code>RADIO/</code>: 包含 <code>radio.img</code> 和 <code>bootloader.img</code> 等。</li>
</ul>
<h3 id="6-常见问题排查">6. 常见问题排查</h3>
<h4 id="61-misc_infotxt-缺失">6.1 <code>misc_info.txt</code> 缺失</h4>
<p><code>misc_info.txt</code> 是 <code>META</code> 目录下的文件，包含系统更新的配置信息。如果生成 OTA 包时提示 <code>misc_info.txt</code> 缺失，可能是因为 <code>target_files.zip</code> 中的设备配置不完整。你需要检查设备的 <code>BoardConfig.mk</code> 是否正确配置，确保包含所有必需的分区信息。</p><h4 id="62-增量-ota-包无法生成">6.2 增量 OTA 包无法生成</h4>
<p>增量 OTA 包生成失败时，可能是由于旧的 <code>target_files.zip</code> 与新的不兼容。例如，系统中的分区布局或签名方式发生了改变。确保旧版本的 <code>target_files.zip</code> 与新版本之间的变化只限于系统级别更新，不涉及分区或签名变化。</p><h4 id="63-aosp-14上在buildtoolsreleasetools-目录下面找不到ota_from_target_files-这个工具">6.3 AOSP 14上在build/tools/releasetools/ 目录下面找不到ota_from_target_files 这个工具</h4>
<p><code>ota_from_target_files</code> 工具在 AOSP 14 中是通过 <code>make</code> 过程生成的，而不是在源代码中直接提供。通常，<code>ota_from_target_files</code> 是在构建 AOSP 时动态生成的。它位于 <code>out/host/linux-x86/bin/</code> 目录下。</p><figure class="post__image"><img loading="lazy" src="https://blog.nasyes.cn/media/posts/6/new_ota_releasetools.jpg" alt="new_ota_releasetools" width="1387" height="755"  sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/6/responsive/new_ota_releasetools-xs.jpg 300w ,https://blog.nasyes.cn/media/posts/6/responsive/new_ota_releasetools-sm.jpg 480w ,https://blog.nasyes.cn/media/posts/6/responsive/new_ota_releasetools-md.jpg 768w ,https://blog.nasyes.cn/media/posts/6/responsive/new_ota_releasetools-lg.jpg 1024w"></figure><h3 id="7-使用-adb-sideload-刷写-ota-包">7. 使用 <code>adb sideload</code> 刷写 OTA 包</h3>
<p>生成 OTA 包后，你可以通过 <code>adb sideload</code> 将 OTA 包刷写到设备上：</p><pre><code class="language-bash">adb reboot recovery
adb sideload out/target/product/&lt;device&gt;/ota_update_full.zip
</code></pre>
<p>设备进入恢复模式后，通过 <code>adb sideload</code> 命令加载并安装 OTA 包。</p><h3 id="8-总结">8. 总结</h3>
<p><code>ota_from_target_files</code> 工具是 Android 构建系统中关键的一部分，用于生成适用于 OTA 更新的 <code>.zip</code> 包。通过正确配置和使用该工具，你可以生成完整或增量的 OTA 包，并使用这些包进行系统升级。</p><p>===========The End===========</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>[GPT]车联网TBox一般运行什么操作系统，有哪些开源实现？</title>
        <author>
            <name>HEIN</name>
        </author>
        <link href="https://blog.nasyes.cn/gptche-lian-wang-tboxyi-ban-yun-xing-shi-me-cao-zuo-xi-tongyou-na-xie-kai-yuan-shi-xian.html"/>
        <id>https://blog.nasyes.cn/gptche-lian-wang-tboxyi-ban-yun-xing-shi-me-cao-zuo-xi-tongyou-na-xie-kai-yuan-shi-xian.html</id>
            <category term="ChatGPT"/>

        <updated>2024-09-20T16:23:04+08:00</updated>
            <summary>
                <![CDATA[
                    车联网中的 TBox（Telematics Box）是一种关键的车载终端设备，负责车辆与外部网络之间的数据交互。TBox 系统通常用于车辆远程控制、位置跟踪、故障诊断等功能。其操作系统和软件实现因不同厂商和功能需求而有所不同。以下是关于 TBox 一般运行的操作系统以及是否有开源实现的详细介绍： 虽然很多 TBox 系统采用专有技术，并且出于安全性和商业竞争原因，厂商往往不会公开其核心实现，但仍然有一些开源项目可以帮助开发 TBox 系统或其中的功能模块： ===========The End===========
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>车联网中的 TBox（Telematics Box）是一种关键的车载终端设备，负责车辆与外部网络之间的数据交互。TBox 系统通常用于车辆远程控制、位置跟踪、故障诊断等功能。其操作系统和软件实现因不同厂商和功能需求而有所不同。以下是关于 TBox 一般运行的操作系统以及是否有开源实现的详细介绍：</p><h3 id="tbox-常用操作系统">TBox 常用操作系统</h3>
<ol>
<li><strong>嵌入式 Linux</strong>：<ul>
<li><strong>概述</strong>：大多数 TBox 使用嵌入式 Linux 操作系统，原因在于其开源、灵活和可定制性。Linux 提供了强大的网络栈、文件系统支持和设备管理功能，适合复杂的车联网应用。</li>
<li><strong>常见发行版</strong>：<ul>
<li><strong>Yocto Project</strong>：Yocto 是一个流行的嵌入式 Linux 发行版构建工具，许多汽车制造商和供应商使用 Yocto 来创建定制的 Linux 镜像。</li>
<li><strong>Ubuntu Core</strong>：针对物联网设备的轻量级 Ubuntu 版本，适合嵌入式系统。</li>
<li><strong>Buildroot</strong>：一个用于生成嵌入式系统的简单、高效的工具包，很多 TBox 开发者也使用它。</li>
</ul>
</li>
</ul>
</li>
<li><strong>QNX</strong>：<ul>
<li><strong>概述</strong>：QNX 是一个商业化的实时操作系统（RTOS），广泛应用于汽车电子系统。它以高可靠性和实时性著称，适合对安全性要求极高的车联网场景。</li>
<li><strong>特点</strong>：QNX 支持高安全性和高性能应用，特别是在需要保证系统稳定性和实时响应的情况下，如自动驾驶和高级驾驶辅助系统（ADAS）。</li>
</ul>
</li>
<li><strong>Android Automotive</strong>：<ul>
<li><strong>概述</strong>：Android Automotive 是谷歌针对汽车行业推出的定制化 Android 系统，主要用于车载娱乐和信息系统，但某些厂商也可能将其与 TBox 集成，以实现更丰富的应用生态系统。</li>
<li><strong>特点</strong>：Android Automotive 提供丰富的应用支持和用户界面，适用于需要与车内娱乐系统和导航集成的 TBox 设备。</li>
</ul>
</li>
<li><strong>实时操作系统（RTOS）</strong>：<ul>
<li><strong>常见 RTOS</strong>：如 FreeRTOS、VxWorks，这类系统以小巧、高效、实时性强著称，适用于较低复杂度的 TBox 系统，尤其是那些需要快速响应的应用。</li>
</ul>
</li>
</ol>
<h3 id="tbox-开源实现">TBox 开源实现</h3>
<p>虽然很多 TBox 系统采用专有技术，并且出于安全性和商业竞争原因，厂商往往不会公开其核心实现，但仍然有一些开源项目可以帮助开发 TBox 系统或其中的功能模块：</p><ol>
<li><strong>GENIVI Alliance</strong>：<ul>
<li><strong>简介</strong>：GENIVI 是一个开源项目联盟，致力于提供标准化的汽车软件平台。虽然它主要专注于车载信息娱乐系统（IVI），但其一些开源组件也可以用于 TBox 系统开发。</li>
<li><strong>地址</strong>：<a href="https://www.genivi.org/">GENIVI</a></li>
</ul>
</li>
<li><strong>AGL (Automotive Grade Linux)</strong>：<ul>
<li><strong>简介</strong>：AGL 是一个专注于汽车应用的开源项目，支持各种车载应用，包括 IVI、TBox、仪表盘等。AGL 是基于 Linux 构建的，并有一套针对汽车行业优化的中间件和框架。</li>
<li><strong>开源代码库</strong>：<a href="https://github.com/automotive-grade-linux">AGL 官方 GitHub</a></li>
</ul>
</li>
<li><strong>Yocto Project</strong>：<ul>
<li><strong>简介</strong>：Yocto 是用于构建嵌入式 Linux 发行版的开源项目。许多 TBox 开发者通过 Yocto 构建定制的 Linux 系统，它支持汽车应用的高可定制化需求。</li>
<li><strong>项目地址</strong>：<a href="https://www.yoctoproject.org/">Yocto Project</a></li>
</ul>
</li>
<li><strong>OpenXC</strong>：<ul>
<li><strong>简介</strong>：OpenXC 是福特公司支持的一个开源平台，用于从汽车数据总线中提取信息。虽然 OpenXC 更侧重于数据提取和处理，但可以作为 TBox 功能开发的基础。</li>
<li><strong>开源代码库</strong>：<a href="https://github.com/openxc">OpenXC GitHub</a></li>
</ul>
</li>
<li><strong>FreeRTOS</strong>：<ul>
<li><strong>简介</strong>：如果你需要在 TBox 上实现高实时性的功能，FreeRTOS 是一个轻量级且广泛使用的 RTOS。虽然不是完整的 TBox 实现，但可以用于开发 TBox 的某些嵌入式模块。</li>
<li><strong>项目地址</strong>：<a href="https://www.freertos.org/">FreeRTOS</a></li>
</ul>
</li>
</ol>
<h3 id="总结">总结</h3>
<ul>
<li><strong>常用操作系统</strong>：TBox 通常运行嵌入式 Linux、QNX、Android Automotive 或 RTOS，如 FreeRTOS 和 VxWorks。</li>
<li><strong>开源项目</strong>：GENIVI、AGL、Yocto Project 和 OpenXC 提供了部分车联网相关的开源实现，这些项目可以用于开发定制的 TBox 系统。</li>
</ul>
<p>===========The End===========</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>AOSP FWK 添加新方法报错：New API must be flagged with @FlaggedApi</title>
        <author>
            <name>HEIN</name>
        </author>
        <link href="https://blog.nasyes.cn/aosp-fwk-tian-jia-xin-fang-fa-bao-cuonew-api-must-be-flagged-with-flaggedapi.html"/>
        <id>https://blog.nasyes.cn/aosp-fwk-tian-jia-xin-fang-fa-bao-cuonew-api-must-be-flagged-with-flaggedapi.html</id>

        <updated>2024-09-03T15:22:26+08:00</updated>
            <summary>
                <![CDATA[
                    在编译 AOSP（Android Open Source Project）时，如果你增加了一个新的静态方法并且遇到了报错，可参考以下方法解决。 没有正确标记新 API： 在 AOSP 中，添加新的 API 或更改现有的 API 需要符合严格的规范。例如，在 Android 框架代码中增加或修改 API 需要使用特定的注释（annotations），如 @FlaggedApi、@SystemApi、@TestApi 等。 如果新增加的静态方法没有正确标记或不符合 API 的规范要求，编译时会出现错误。 解决方法： 使用适当的注解来标记新的静态方法。例如：&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <p>在编译 AOSP（Android Open Source Project）时，如果你增加了一个新的静态方法并且遇到了报错，可参考以下方法解决。</p><h3 id="常见原因及解决方法">常见原因及解决方法</h3>
<ol>
<li><p><strong>没有正确标记新 API</strong>：
在 AOSP 中，添加新的 API 或更改现有的 API 需要符合严格的规范。例如，在 Android 框架代码中增加或修改 API 需要使用特定的注释（annotations），如 <code>@FlaggedApi</code>、<code>@SystemApi</code>、<code>@TestApi</code> 等。</p><p>如果新增加的静态方法没有正确标记或不符合 API 的规范要求，编译时会出现错误。</p><p><strong>解决方法</strong>：
使用适当的注解来标记新的静态方法。例如：</p><pre><code class="language-java">@FlaggedApi(&quot;Sth to describe the method.&quot;)
public static void myNewStaticMethod() {
    // method implementation
}
</code></pre>
</li>
<li><p><strong>API 签名检查失败</strong>：
当你在 AOSP 中增加或更改 API 时，编译过程会检查这些更改是否符合 <code>current.txt</code>、<code>removed.txt</code> 等 API 签名文件的定义。如果增加的 API 不在这些文件中，编译会失败。</p><p><strong>解决方法</strong>：</p><ul>
<li>更新相关的 API 签名文件，例如 <code>frameworks/base/api/current.txt</code>，将新增的 API 签名添加到该文件中。</li>
<li>运行以下命令来生成和更新 API 签名：<pre><code class="language-bash">make update-api
</code></pre>
</li>
</ul>
<p>这将自动更新 API 文件以匹配你所做的更改。</p></li>
<li><p><strong>Java 语言层级不匹配</strong>：
AOSP 使用特定的 Java 语言版本来编译代码。确保你使用的语法和语言特性与 AOSP 项目的 Java 编译器设置相匹配。</p><p><strong>解决方法</strong>：</p><ul>
<li>确保你的代码没有使用高于当前 AOSP 项目所支持的 Java 版本的特性。</li>
</ul>
</li>
<li><p><strong>依赖库或模块缺失</strong>：
如果你的新方法使用了某些依赖，但这些依赖没有被正确地添加到相应的 <code>Android.bp</code> 或 <code>Android.mk</code> 构建文件中，也可能会导致编译错误。</p><p><strong>解决方法</strong>：</p><ul>
<li>确保所有需要的依赖和模块已经在相应的构建文件中正确声明。</li>
</ul>
</li>
<li><p><strong>ProGuard 混淆规则冲突</strong>：
如果你在 <code>proguard-rules.pro</code> 文件中定义了混淆规则，这些规则可能会与新的静态方法发生冲突，导致编译错误。</p><p><strong>解决方法</strong>：</p><ul>
<li>检查混淆规则文件，并确保其中的规则不会对新增加的静态方法产生不良影响。</li>
</ul>
</li>
</ol>
<h3 id="如何进一步排查问题">如何进一步排查问题</h3>
<ul>
<li><strong>查看详细错误信息</strong>：编译 AOSP 时，查看输出日志中的错误信息，它通常会指出错误的具体位置和原因。</li>
<li><strong>检查更改的文件</strong>：确保你修改的文件没有其他编译器不支持的更改。</li>
<li><strong>清理构建环境</strong>：尝试清理构建环境，重新构建项目：<pre><code class="language-bash">make clean
make
</code></pre>
</li>
</ul>

            ]]>
        </content>
    </entry>
    <entry>
        <title>OpenHarmony在树莓派4B上的初步移植和编译、刷机</title>
        <author>
            <name>HEIN</name>
        </author>
        <link href="https://blog.nasyes.cn/openharmonyzai-shu-mei-pai-4shang-de-chu-bu-yi-zhi-he-bian-yishua-jidiao-shi.html"/>
        <id>https://blog.nasyes.cn/openharmonyzai-shu-mei-pai-4shang-de-chu-bu-yi-zhi-he-bian-yishua-jidiao-shi.html</id>

        <updated>2024-05-23T10:06:07+08:00</updated>
            <summary>
                <![CDATA[
                    1. OpenHarmony简介 仓库主页：https://gitee.com/openharmony 项目官网：https://www.openharmony.cn/mainPlay OpenHarmony是由开放原子开源基金会（OpenAtom Foundation）孵化及运营的开源项目，目标是面向全场景、全连接、全智能时代，基于开源的方式，搭建一个智能终端设备操作系统的框架和平台，促进万物互联产业的繁荣发展。 鸿蒙从华为诞生之后，华为在2020年9月和2021年5月分两次将HarmonyOS的基础能力代码全部捐献给开放原子开源基金会（https://www.openatom.org），这是鸿蒙操作系统发展历程中非常重要的事件。所谓“基础能力代码”，是HarmonyOS中与华为自家的产品和商业模式无关的那部分代码。 开放原子开源基金会成立于2020年，是国内第一家开源基金会。 开放原子开源基金会在接收到华为捐赠的代码之后，就遵循 Apache 许可协议代码开源了，同时创立了一个开源项目，并将其命名为 OpenHarmony（开源鸿蒙）。下面是OpenHarmony的部分发展历程，可查阅https://gitee.com/openharmony/docs/tree/master/zh-cn/release-notes 获取更详细的信息。 Android 是一个基于 Linux 的开源软件堆栈，针对多种不同设备类型打造。下图显示了 Android 平台的主要组件。 详情可参考：https://developer.android.google.cn/guide/platform?hl=zh-cn OpenHarmony支持如下几种系统类型： 轻量系统（mini system） 面向MCU类处理器例如Arm Cortex-M、RISC-V&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                <h2>1. OpenHarmony简介</h2>
<p>仓库主页：<a href="https://www.openharmony.cn/mainPlay" target="_blank" rel="noopener noreferrer">https://gitee.com/openharmony</a></p>
<p>项目官网：<a href="https://www.openharmony.cn/mainPlay" target="_blank" rel="noopener noreferrer"></a><a href="https://www.openharmony.cn/mainPlay" target="_blank" rel="noopener noreferrer"></a><a href="https://www.openharmony.cn/mainPlay" target="_blank" rel="noopener noreferrer">https://www.openharmony.cn/mainPlay</a></p>
<blockquote>
<p>OpenHarmony是由开放原子开源基金会（OpenAtom Foundation）孵化及运营的开源项目，目标是面向全场景、全连接、全智能时代，基于开源的方式，搭建一个智能终端设备操作系统的框架和平台，促进万物互联产业的繁荣发展。</p>
</blockquote>
<div>
<div>
<div>
<div> </div>
</div>
鸿蒙操作系统最早是由华为进行研发和发布，可查阅：<a href="https://www.harmonyos.com/cn/information/">https://www.harmonyos.com/cn/information/</a>获取华为发布鸿蒙的信息。</div>
<div>
<div>
<p data-pid="nAI-2kSQ">鸿蒙从华为诞生之后，华为在2020年9月和2021年5月分两次将HarmonyOS的基础能力代码全部捐献给开放原子开源基金会<svg width="10px" height="10px" viewbox="0 0 15 15" class="css-1dvsrp"><path d="M10.89 9.477l3.06 3.059a1 1 0 0 1-1.414 1.414l-3.06-3.06a6 6 0 1 1 1.414-1.414zM6 10a4 4 0 1 0 0-8 4 4 0 0 0 0 8z" fill="currentColor"></path></svg>（https://www.openatom.org），这是鸿蒙操作系统发展历程中非常重要的事件。所谓“基础能力代码”，是HarmonyOS中与华为自家的产品和商业模式无关的那部分代码。</p>
<p data-pid="nAI-2kSQ">开放原子开源基金会成立于2020年，是国内第一家开源基金会。</p>
<p data-pid="7BBS3Zl_">开放原子开源基金会在接收到华为捐赠的代码之后，就遵循 Apache 许可协议代码开源了，同时创立了一个开源项目，并将其命名为 OpenHarmony（开源鸿蒙）。下面是OpenHarmony的部分发展历程，可查阅<a href="https://gitee.com/openharmony/docs/tree/master/zh-cn/release-notes">https://gitee.com/openharmony/docs/tree/master/zh-cn/release-notes</a> 获取更详细的信息。</p>
</div>
</div>
<div>下图是HarmonyOS(右)和OpenHarmony(左)的发展时间线，供参考。</div>
<div>
<figure class="post__image"><img loading="lazy"  src="https://blog.nasyes.cn/media/posts/3/OH-Tileline.png" alt="" width="2369" height="1347" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/OH-Tileline-xs.png 300w ,https://blog.nasyes.cn/media/posts/3/responsive/OH-Tileline-sm.png 480w ,https://blog.nasyes.cn/media/posts/3/responsive/OH-Tileline-md.png 768w ,https://blog.nasyes.cn/media/posts/3/responsive/OH-Tileline-lg.png 1024w"><figcaption>HarmonyOS(右)和OpenHarmony(左)的发展时间线</figcaption></figure>
</div>
<h2>2. OpenHarmony和AOSP的技术架构对比</h2>
<h3>· OpenHarmony</h3>
OpenHarmony整体遵从分层设计，从下向上依次为：内核层、系统服务层、框架层和应用层。系统功能按照“系统 &gt; 子系统 &gt; 组件”逐级展开，在多设备部署场景下，支持根据实际需求裁剪某些非必要的组件。OpenHarmony技术架构如下所示：<br>
<figure class="post__image" ><img loading="lazy" style="outline: 3px solid rgba(var(--color-primary-rgb), 0.55) !important;" src="https://blog.nasyes.cn/media/posts/3/OH-Stack.png" alt="OpenHarmony技术架构" width="1783" height="866" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/OH-Stack-xs.png 300w ,https://blog.nasyes.cn/media/posts/3/responsive/OH-Stack-sm.png 480w ,https://blog.nasyes.cn/media/posts/3/responsive/OH-Stack-md.png 768w ,https://blog.nasyes.cn/media/posts/3/responsive/OH-Stack-lg.png 1024w">
<figcaption >OpenHarmony技术架构</figcaption>
</figure>
</div>
<blockquote>
<div>详情可参考：<a href="https://gitee.com/openharmony#%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84">https://gitee.com/openharmony#技术架构</a></div>
</blockquote>
<div>
<h3>· AOSP</h3>
<p>Android 是一个基于 Linux 的开源软件堆栈，针对多种不同设备类型打造。下图显示了 Android 平台的主要组件。</p>
<figure class="post__image"><img loading="lazy"  src="https://blog.nasyes.cn/media/posts/3/android-stack_2x-3.png" alt="" width="800" height="1178" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/android-stack_2x-3-xs.png 300w ,https://blog.nasyes.cn/media/posts/3/responsive/android-stack_2x-3-sm.png 480w ,https://blog.nasyes.cn/media/posts/3/responsive/android-stack_2x-3-md.png 768w ,https://blog.nasyes.cn/media/posts/3/responsive/android-stack_2x-3-lg.png 1024w"><figcaption>Android 软件栈</figcaption></figure>
<blockquote>
<p>详情可参考：<a href="https://developer.android.google.cn/guide/platform?hl=zh-cn">https://developer.android.google.cn/guide/platform?hl=zh-cn</a></p>
</blockquote>
</div>
<h2>3. OpenHarmony主库版本编译</h2>
<p>OpenHarmony支持如下几种系统类型：</p>
<ul>
<li>
<p><strong>轻量系统（mini system）</strong></p>
<p>面向MCU类处理器例如Arm Cortex-M、RISC-V 32位的设备，硬件资源极其有限，支持的设备最小内存为128KiB，可以提供多种轻量级网络协议，轻量级的图形框架，以及丰富的IOT总线读写部件等。可支撑的产品如智能家居领域的连接类模组、传感器设备、穿戴类设备等。</p>
</li>
<li>
<p><strong>小型系统（small system）</strong></p>
<p>面向应用处理器例如Arm Cortex-A的设备，支持的设备最小内存为1MiB，可以提供更高的安全能力、标准的图形框架、视频编解码的多媒体能力。可支撑的产品如智能家居领域的IP Camera、电子猫眼、路由器以及智慧出行域的行车记录仪等。</p>
</li>
<li>
<p><strong>标准系统（standard system）</strong></p>
<p>面向应用处理器例如Arm Cortex-A的设备，支持的设备最小内存为128MiB，可以提供增强的交互能力、3D GPU以及硬件合成能力、更多控件以及动效更丰富的图形能力、完整的应用框架。可支撑的产品如高端的冰箱显示屏。</p>
</li>
</ul>
<p>后续内容如果没有特别说明，都是以标准系统为示例进行介绍的。</p>
<p>官方的文档中也有详细的说明，此处仅作简要总结。</p>
<h4>3.1 下载源码</h4>
<p>OpenHarmony的代码以组件的形式开放，开发者可以通过如下其中一种方式获取：</p>
<ul>
<li>
<p><strong>获取方式1</strong>：从码云代码仓库获取。通过repo或git工具从代码仓库中下载，此方式可获取最新代码。</p>
</li>
<li>
<p><strong>获取方式2</strong>：通过<a href="https://gitee.com/link?target=https%3A%2F%2Frepo.harmonyos.com%2F%23%2Fcn%2Fhome">DevEco Marketplace</a>网站获取。访问<a href="https://gitee.com/link?target=https%3A%2F%2Frepo.harmonyos.com%2F%23%2Fcn%2Fhome">DevEco Marketplace</a>网站，查找满足需求的开源发行版，直接下载（或者定制后下载），再通过hpm-cli命令工具将所需的组件及工具链下载、安装到本地。</p>
</li>
<li>
<p><strong>获取方式3</strong>：从镜像站点下载归档后的发行版压缩文件。如果要获取旧版本的源码，也可通过此方式获取，此方式下载速度较快。</p>
</li>
<li>
<p><strong>获取方式4</strong>：从github代码仓库获取。通过repo或git工具从代码仓库中下载，此方式可获取最新代码。</p>
</li>
</ul>
<p>详细获取方式可参考 <a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/get-code/sourcecode-acquire.md">https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/get-code/sourcecode-acquire.md</a></p>
<h4>3.2 编译构建</h4>
<p>OpenHarmony编译子系统是以GN和Ninja构建为基座，对构建和配置粒度进行部件化抽象、对内建模块进行功能增强、对业务模块进行功能扩展的系统，该系统提供以下基本功能：</p>
<ul>
<li>以部件为最小粒度拼装产品和独立编译。</li>
<li>支持轻量、小型、标准三种系统的解决方案级版本构建，以及用于支撑应用开发者使用IDE开发的SDK开发套件的构建。</li>
<li>支持芯片解决方案厂商的灵活定制和独立编译。</li>
</ul>
<figure class="post__image"><img loading="lazy"  src="https://blog.nasyes.cn/media/posts/3/compilation_process.png" alt="" width="882" height="563" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/compilation_process-xs.png 300w ,https://blog.nasyes.cn/media/posts/3/responsive/compilation_process-sm.png 480w ,https://blog.nasyes.cn/media/posts/3/responsive/compilation_process-md.png 768w ,https://blog.nasyes.cn/media/posts/3/responsive/compilation_process-lg.png 1024w"><figcaption>编译构建流程</figcaption></figure>
<p>根据官网的提醒，编译环境目前主要支持Ubuntu18.04和Ubuntu20.04（Ubuntu22.04暂不支持）。后面会介绍22.04上的编译适配方法。</p>
<p>完整的编译步骤可以参考<a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/subsystems/subsys-build-all.md">https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/subsystems/subsys-build-all.md</a></p>
<h4>3.3 打包及刷机</h4>
<p>在不同的设备和开发板上打包和刷机的方式不完全相同，后面介绍树莓派4B设备上的打包和刷机步骤，可供其它设备参考。</p>
<h2>4. OpenHarmony在树莓派4B上的编译和刷机步骤</h2>
<blockquote>
<p>IT之家 2 月 8 日消息，据<span class="profile_nickname"> OpenAtom OpenHarmony 官方消息，</span>近期，在中国科学院软件研究所的技术支撑下，<span class="accentTextColor">树莓派 4B（Raspberry Pi 4 Model B）开发板顺利通过 OpenHarmony 3.2.4 Release 版本兼容性测评</span>，并 获 颁 OpenHarmony 生 态 产 品 兼 容 性 证 书 ，突破性推动树莓派 4B 开发板加入 OpenHarmony 生态，为 OpenHarmony 落地教育、物联网和嵌入式等开发领域提供了新的支点。<br><a href="https://baijiahao.baidu.com/s?id=1790323159836926636">树莓派 4B 开发板通过开源鸿蒙 OpenHarmony 兼容性测评 </a></p>
</blockquote>
<p>在OpenHarmony-SIG上可以找到用于兼容性测试的树莓派4B分支，基于3.2R版本。但是这个版本在实际操作后，产生的版本无法在开发板上运行，所以参考它的步骤，做一些调整后，可产生可用的系统镜像。原步骤文档可参考：<a href="https://gitee.com/openharmony-sig/device_board_rpi/blob/OpenHarmony-3.2-Release/rpi4/README_zh.md">https://gitee.com/openharmony-sig/device_board_rpi/blob/OpenHarmony-3.2-Release/rpi4/README_zh.md</a></p>
<h4>4.1 树莓派4B开发板介绍</h4>
<p>树莓派由注册于英国的“Raspberry Pi 慈善基金会”开发，<span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">它是一款基于ARM的微型电脑主板。技术文档可参考：<a href="https://datasheets.raspberrypi.com/rpi4/raspberry-pi-4-product-brief.pdf">https://datasheets.raspberrypi.com/rpi4/raspberry-pi-4-product-brief.pdf</a></span></p>
<figure class="post__image"><img loading="lazy"  src="https://blog.nasyes.cn/media/posts/3/rpi4.png" alt="" width="1171" height="723" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/rpi4-xs.png 300w ,https://blog.nasyes.cn/media/posts/3/responsive/rpi4-sm.png 480w ,https://blog.nasyes.cn/media/posts/3/responsive/rpi4-md.png 768w ,https://blog.nasyes.cn/media/posts/3/responsive/rpi4-lg.png 1024w"><figcaption>树莓派4B开发板外观和接口介绍</figcaption></figure>
<figure class="post__image" ><img loading="lazy" src="https://blog.nasyes.cn/media/posts/3/rpi4_specification.jpg" alt="" width="977" height="1235" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/rpi4_specification-xs.jpg 300w ,https://blog.nasyes.cn/media/posts/3/responsive/rpi4_specification-sm.jpg 480w ,https://blog.nasyes.cn/media/posts/3/responsive/rpi4_specification-md.jpg 768w ,https://blog.nasyes.cn/media/posts/3/responsive/rpi4_specification-lg.jpg 1024w">
<figcaption >树莓派4B 技术规格</figcaption>
</figure>
<h4>4.2 搭建开发环境</h4>
<p>根据SIG-3.2R分支上的编译步骤进行配置后，多次尝试编译的镜像都有无法启动(黑屏)的问题，所以我们采用拉取主仓库代码+Vendor适配的方式进行配置，多次尝试后，4.0R版本可以运行在树莓派4B的版本上，此处感谢Gitee上 <a href="https://gitee.com/diemit">@diemit</a> 的答疑解惑，帮助解决和排查了很多补丁和编译的问题。</p>
<h5>1) <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">下载repo脚本文件</span></h5>
<div>
<ul>
<li>注册码云gitee账号。</li>
<li>注册码云SSH公钥，请参考码云帮助中心。</li>
<li>安装git客户端和git-lfs并配置用户信息。</li>
</ul>
</div>
<pre class="language-apacheconf"><code>git config --global user.name "yourname"
git config --global user.email "your-email-address"
git config --global credential.helper store</code></pre>
<div>
<ul>
<li>安装码云repo工具，可以执行如下命令。</li>
</ul>
</div>
<pre class="language-apacheconf"><code>curl -s https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 &gt; /usr/local/bin/repo  
pip3 install -i https://repo.huaweicloud.com/repository/pypi/simple requests</code></pre>
<div>
<div>如果没有权限，可下载至其他目录，并将其配置到环境变量中<br>
<pre class="language-apacheconf"><code>mkdir ~/bin
curl https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 -o ~/bin/repo 
chmod a+x ~/bin/repo
pip3 install -i https://repo.huaweicloud.com/repository/pypi/simple requests</code></pre>
</div>
</div>
<pre class="language-apacheconf"><code>vim ~/.bashrc               # 编辑环境变量
export PATH=~/bin:$PATH     # 在环境变量的最后添加一行repo路径信息
source ~/.bashrc            # 应用环境变量</code></pre>
<h5>2) <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">获取OpenHarmony标准系统源码</span></h5>
<p><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">通过repo + ssh 下载（需注册公钥，请参考码云帮助中心）。</span></p>
<div>
<div>
<pre class="language-apacheconf"><code>export WORK_SPACE=/home/xxx/OpenHarmony #替换成自己定义的workspace路径
export PROJ_ROOT=$WORK_SPACE/4.0-Release
mkdir $WORK_SPACE
mkdir $PROJ_ROOT
cd $PROJ_ROOT
#repo init -u https://gitee.com/openharmony/manifest -b OpenHarmony-4.0-Release --no-repo-verify
repo init -u https://gitee.com/openharmony/manifest -b refs/tags/OpenHarmony-v4.0-Release --no-repo-verify
repo sync -c
repo forall -c 'git lfs pull'</code></pre>
</div>
</div>
<p>这里要注意，上面注释掉的一行是原来的官方提供的检出4.0R版本的代码的方式，但是经过我的编译和运行测试，发现4.0R分支释放之后仍然是有代码合入的，从而引入了一些问题，导致树莓派4B移植的补丁合入出现兼容性问题。所以为了防止出现此类问题，改为检出4.0R TAG的代码，保证代码的一致性。</p>
<h5>3) <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">获取编译工具链</span></h5>
<p>参考<a href="https://gitee.com/openharmony/docs/tree/master/zh-cn/device-dev/quick-start">OpenHamony快速入门文档</a>，基于命令行入门。</p>
<pre class="language-apacheconf"><code>sudo apt-get update &amp;&amp; sudo apt-get install binutils git git-lfs gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip m4 bc gnutls-bin python3.8 python3-pip ruby default-jdk libssl-dev libtinfo5 genext2fs u-boot-tools mtools mtd-utils scons gcc-arm-none-eabi abootimg</code></pre>
<p>此处是基于Ubuntu20.04的版本进行的工具链安装。经过实际测试，在22.04上可以按照此方法进行安装，但是由于Ubuntu22.04的系统默认Python版本是3.10，而OpenHarmony目前的编译工具均基于Python3.8进行编写。所以如果要在22.04上编译OpenHarmony系统，需要手动切换系统默认Python版本为3.8。下面是具体的切换方法，请参考。</p>
<pre class="language-apacheconf"><code># 手动添加安装源
# 如果添加失败，则手动编辑sources.list文件，把安装源添加到文件最后
sudo echo 'deb https://launchpad.proxy.ustclug.org/deadsnakes/ppa/ubuntu/ jammy main' &gt;&gt; /etc/apt/sources.list

# 添加证书
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA6932366A755776

# 更新源后安装Python3.8
sudo apt update
sudo apt install -y python3.8 libpython3.8-dev python3.8-dev python3.8-distutils
#查看当前安装的Python版本
ls /usr/bin/python*
# 设置Python顺序
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.10 1
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.8 2
# 如果需要调整python3的顺序，则运行下列命令后选择新的顺序即可
sudo update-alternatives --config python3</code></pre>
<h5>4) <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">执行预编译脚本prebuilts</span></h5>
<p><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">在源码根目录下执行脚本，安装编译器及二进制工具。</span></p>
<div>
<div>
<pre class="language-apacheconf"><code>cd $PROJ_ROOT
bash build/prebuilts_download.sh</code></pre>
</div>
<div>等待下载完成即可。</div>
<h5>5) 下载树莓派4B补丁到主库代码目录中</h5>
<div>
<pre class="language-apacheconf"><code>git clone -b OpenHarmony-4.0-Release https://gitee.com/ohos-porting-communities/vendor_opc.git vendor/opc
git clone -b OpenHarmony-4.0-Release https://gitee.com/ohos-porting-communities/device_board_opc.git device/board/opc
git clone -b OpenHarmony-4.0-Release https://gitee.com/ohos-porting-communities/device_soc_opc.git device/soc/opc</code></pre>
</div>
<h5>6) 补丁合入</h5>
<p>使用git合入diff补丁</p>
<div>
<pre class="language-apacheconf"><code>#device/board/opc/common/patches

#编译白名单补丁：
#001-build.diff -&gt; build

#树莓派4B启用CPU渲染/GPU渲染黑屏修复与其他设备Mesa3D驱动修改补丁：
#002-graphic_2d.diff -&gt; foundation/graphic/graphic_2d</code></pre>
</div>
<h5>7) 配置默认启动位置</h5>
<div>
<pre class="language-apacheconf"><code>#补丁里树莓派4B默认挂载配置为U盘启动方式，需要修改启动方式为从microSD卡启动
#修改以下文件，切换挂载分区

device/board/opc/rpi4/cfg/fstab.required
device/board/opc/rpi4/cfg/fstab.rpi4</code></pre>
</div>
<div>至此代码和编译环境准备完毕。</div>
</div>
<h4>4.3 编译、烧录和调试</h4>
<p>编译阶段就比较简单了，只要前面按照步骤都配置好了，编译过程应该只是时间问题。</p>
<h5>1) <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">OpenHarmony编译</span></h5>
<pre class="language-apacheconf"><code>cd $PROJ_ROOT 
./build.sh --product-name rpi4 --ccache --no-prebuilt-sdk</code></pre>
<div>
<div>编译成功提示:</div>
</div>
<pre class="language-apacheconf"><code>post_process
=====build beryllium successful.</code></pre>
<div>
<div>编译生成的文件：</div>
<div>
<pre class="language-apacheconf"><code>$PROJ_ROOT/out/rpi4/packages/phone/images/system.img 
$PROJ_ROOT/out/rpi4/packages/phone/images/vendor.img
$PROJ_ROOT/out/rpi4/packages/phone/images/userdata.img
$PROJ_ROOT/out/rpi4/packages/phone/images/ramdisk.img</code></pre>
</div>
</div>
<h5>2) 树莓派4B打包镜像编译</h5>
<p><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">编译好OpenHarmony的文件之后使用以下命令内核并打包手机boot.img/树莓派4B完整镜像</span></p>
<pre class="language-apacheconf"><code>#树莓派4B
./build.sh --product-name rpi4 --ccache --no-prebuilt-sdk --build-target rpi_image</code></pre>
<h5>3) 镜像烧录</h5>
<pre class="language-apacheconf"><code>#树莓派4B使用Win32DiskImager烧录整合好的rpi_image.img到microSD卡中</code></pre>
<p>至此树莓派4B即可运行OpenHarmony 4.0R的系统。</p>
<h5>4) 调试</h5>
<h6>A. 串口调试</h6>
<p>串口引脚图如下：</p>
<figure class="post__image"><img loading="lazy"  src="https://blog.nasyes.cn/media/posts/3/rpi4ck.png" alt="" width="1977" height="1069" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/rpi4ck-xs.png 300w ,https://blog.nasyes.cn/media/posts/3/responsive/rpi4ck-sm.png 480w ,https://blog.nasyes.cn/media/posts/3/responsive/rpi4ck-md.png 768w ,https://blog.nasyes.cn/media/posts/3/responsive/rpi4ck-lg.png 1024w"></figure>
<pre class="language-apacheconf"><code>(1) 连接图中6、8、10三个引脚。
(2) 打开Xshell，新建会话，在连接的协议中选择SERIAL。
(3) 转到串口标签，选择正确的端口号，波特率115200，完成后即可连接。</code></pre>
<h6>B. 使用HDC工具</h6>
<pre class="language-apacheconf"><code>(1)hdc_std shell:进入命令行
(2)hdc_std file send {本地系统文件路径} {oh系统文件路径}:发送文件
(3)hdc_std file recv {oh系统文件路径} {本地系统文件路径}:接收文件
(4)hdc_std install XXX.hap:安装hap包</code></pre>
<h4>5. OpenHarmony设备挑选和移植指南</h4>
<h4>5.1 官方设备的挑选</h4>
<p>目前官方社区支持的开发板可以从以下网址中获取信息：</p>
<p><a href="https://ci.openharmony.cn/workbench/develop/all">https://ci.openharmony.cn/workbench/develop/all</a></p>
<p>其中支持标准系统的包含以下三款(从左到右分别是恩智浦、意法半导体和瑞芯微三款芯片的板级支持)：</p>
<figure class="post__image"><img loading="lazy"  src="https://blog.nasyes.cn/media/posts/3/standard_dev_board.png" alt="" width="2045" height="859" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/standard_dev_board-xs.png 300w ,https://blog.nasyes.cn/media/posts/3/responsive/standard_dev_board-sm.png 480w ,https://blog.nasyes.cn/media/posts/3/responsive/standard_dev_board-md.png 768w ,https://blog.nasyes.cn/media/posts/3/responsive/standard_dev_board-lg.png 1024w"><figcaption>官方支持的几款标准系统开发板</figcaption></figure>
<p>其中以RK3568芯片为主的各种国产开发板均基本都可以使用主库代码进行编译刷入，门槛较低，适配性较好。</p>
<h4>5.2 可移植设备的挑选</h4>
<p>除了官方社区支持的开发板，还有一种方案就是对现有的设备进行移植。特别是一些支持或兼容支持Android的设备是较为合适的选择。以下参考 <a href="https://ost.51cto.com/posts/20849">https://ost.51cto.com/posts/20849</a> ，根据作者的移植经验和总结，大致梳理一下可移植设备的初步挑选方法。</p>
<h5>1) <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">移植设备可行性评估</span></h5>
<p> </p>
<div>① 确认你要移植的设备可以解锁刷机<br>② 确认你的设备有TWRP类似的第三方Recovery，方便刷机<br>③ 确认有可用的内核源码版本，不是内核源码开源就能移植的，OpenHarmony的内核④ 目前为止是以标准Linux5.10内核为基础的，4.19已不再支持，移植时需要你的设备有5.10或者5.10以上的内核源码，理论上其他版本也可以，但是要求你是内核大神，精通各个版本内核的变动，并了解驱动如何升级降级适配。<br>⑤ 确认设备驱动源码、固件是否可以获取到</div>
<p>快速评估入口：<a href="https://wiki.postmarketos.org/wiki/Devices">https://wiki.postmarketos.org/wiki/Devices</a></p>
<p>根据表格中的提示：</p>
<figure class="post__image align-center"><img loading="lazy"  src="https://blog.nasyes.cn/media/posts/3/devices_features_marks.png" alt="" width="381" height="181" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/devices_features_marks-xs.png 300w ,https://blog.nasyes.cn/media/posts/3/responsive/devices_features_marks-sm.png 480w ,https://blog.nasyes.cn/media/posts/3/responsive/devices_features_marks-md.png 768w ,https://blog.nasyes.cn/media/posts/3/responsive/devices_features_marks-lg.png 1024w"></figure>
<p><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">尽量选择全Y的设备，至少也要是P，如果某一项没有得到Y或者P，则说明此功能大概率是不可用的状态。</span></p>
<p>同理，如果选择Testing中的设备，那么要查看Features的可用性，举例树莓派4B：</p>
<figure class="post__image align-center"><img loading="lazy"  src="https://blog.nasyes.cn/media/posts/3/rpi4_features_supported.png" alt="" width="338" height="658" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/rpi4_features_supported-xs.png 300w ,https://blog.nasyes.cn/media/posts/3/responsive/rpi4_features_supported-sm.png 480w ,https://blog.nasyes.cn/media/posts/3/responsive/rpi4_features_supported-md.png 768w ,https://blog.nasyes.cn/media/posts/3/responsive/rpi4_features_supported-lg.png 1024w"></figure>
<p>总之，查询后设备的特性支持的越多，移植成功的概率就越高。</p>
<h5>2) <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">移植概述</span></h5>
<p> </p>
<div>① 准备OpenHarmony代码编译环境，下载源码（社区有大量帖子介绍OH环境安装，在此不再重复介绍）<br>② 官方设备（rk3568）编译一次确认环境配置正确<br>③ 准备postmarketOS编译环境，并进行一次编译（方便获取boot配置，内核配置，驱动固件等）<br>④ 利用第三方内核移植加入OH内核特性的方式，移植适配内核<br>⑤ 移植适配OH的init启动脚本，图形渲染框架<br>⑥ 编译OH系统刷机文件<br>⑦ 利用解包打包工具，打包出自己的boot.img<br>⑧ 利用twrp刷入boot.img，system.img，vendor.img实现OH的启动<br>
<h5>3) 移植适配相关知识储备</h5>
<p> </p>
① 操作系统相关知识，设备启动相关知识<br>② Linux内核相关知识，驱动相关知识<br>③ OpenHarmony系统相关知识<br>④ Linux操作系统命令相关知识<br>⑤ 设备（安卓手机，平板，开发板等）相关知识</div>
<div><br>
<p>===========The End===========</p>
</div>
            ]]>
        </content>
    </entry>
</feed>
