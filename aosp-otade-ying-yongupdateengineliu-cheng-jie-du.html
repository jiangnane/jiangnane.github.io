<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>AOSP OTA包的应用：update_engine模块解读 - HEIN&#x27;s Blog</title><meta name="robots" content="noindex,nofollow"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="alternate" type="application/atom+xml" href="https://blog.nasyes.cn/feed.xml" title="HEIN&#x27;s Blog - RSS"><link rel="alternate" type="application/json" href="https://blog.nasyes.cn/feed.json" title="HEIN&#x27;s Blog - JSON"><meta property="og:title" content="AOSP OTA包的应用：update_engine模块解读"><meta property="og:site_name" content="HEIN's Blog"><meta property="og:description" content="本文旨在详细介绍 Android 11 的 update_engine 模块，包括更新流程、代码分析、增量更新技术及其对外部库的依赖。 update_engine 是 Android 系统负责 OTA 更新的核心模块，尤其适用于 A/B 分区机制。它在后台应用更新，确保设备无缝更新，且在更新失败时自动回滚到稳定版本。 操作主体：SystemUpdateManager、DownloadManager 系统更新的检查和下载是由 APP 层负责的，通常通过 Google Play 服务或定制的 OTA 服务器。 检查更新： SystemUpdateManager&hellip;"><meta property="og:url" content="https://blog.nasyes.cn/aosp-otade-ying-yongupdateengineliu-cheng-jie-du.html"><meta property="og:type" content="article"><link rel="preload" href="https://blog.nasyes.cn/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://blog.nasyes.cn/assets/css/style.css?v=1f557c81d98d81d721608200b8db7e33"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.nasyes.cn/aosp-otade-ying-yongupdateengineliu-cheng-jie-du.html"},"headline":"AOSP OTA包的应用：update_engine模块解读","datePublished":"2024-09-23T17:08+08:00","dateModified":"2024-09-27T11:10+08:00","description":"本文旨在详细介绍 Android 11 的 update_engine 模块，包括更新流程、代码分析、增量更新技术及其对外部库的依赖。 update_engine 是 Android 系统负责 OTA 更新的核心模块，尤其适用于 A/B 分区机制。它在后台应用更新，确保设备无缝更新，且在更新失败时自动回滚到稳定版本。 操作主体：SystemUpdateManager、DownloadManager 系统更新的检查和下载是由 APP 层负责的，通常通过 Google Play 服务或定制的 OTA 服务器。 检查更新： SystemUpdateManager&hellip;","author":{"@type":"Person","name":"HEIN","url":"https://blog.nasyes.cn/authors/hein/"},"publisher":{"@type":"Organization","name":"HEIN"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body><div class="container container--center"><header class="header"><div class="header__logo"><a class="logo" href="https://blog.nasyes.cn/">HEIN&#x27;s Blog</a></div></header><main class="content"><article class="post"><header><h1 class="post__title">AOSP OTA包的应用：update_engine模块解读</h1><div class="post__meta"><time datetime="2024-09-23T17:08" class="post__date">九月 23, 2024 </time><span class="post__author"><a href="https://blog.nasyes.cn/authors/hein/" class="feed__author">HEIN</a></span></div></header><div class="post__entry"><p>本文旨在详细介绍 Android 11 的 <code>update_engine</code> 模块，包括更新流程、代码分析、增量更新技术及其对外部库的依赖。</p><hr><h3 id="一、update_engine-简介">一、<code>update_engine</code> 简介</h3><p><code>update_engine</code> 是 Android 系统负责 OTA 更新的核心模块，尤其适用于 A/B 分区机制。它在后台应用更新，确保设备无缝更新，且在更新失败时自动回滚到稳定版本。</p><hr><h3 id="二、更新流程及代码分析">二、更新流程及代码分析</h3><h4 id="1-系统更新检查与下载（app-层）">1. <strong>系统更新检查与下载</strong>（APP 层）</h4><ul><li><p><strong>操作主体</strong>：<code>SystemUpdateManager</code>、<code>DownloadManager</code></p><p>系统更新的检查和下载是由 APP 层负责的，通常通过 Google Play 服务或定制的 OTA 服务器。</p><ul><li><p><strong>检查更新</strong>：</p><pre><code class="language-java">SystemUpdateManager systemUpdateManager = new SystemUpdateManager();
boolean isUpdateAvailable = systemUpdateManager.isUpdateAvailable();
</code></pre><p>通过 <code>SystemUpdateManager</code> 与后台交互，检查是否有新的 OTA 更新可用。</p></li><li><p><strong>下载更新</strong>： 使用 <code>DownloadManager</code> 或自定义组件下载更新包。当下载完成后，系统会通知 <code>update_engine</code> 开始更新。</p></li></ul></li></ul><h4 id="2-验证与应用更新包（update_engine）">2. <strong>验证与应用更新包</strong>（<code>update_engine</code>）</h4><ul><li><p><strong>验证更新包</strong>： 下载完成的更新包交给 <code>update_engine</code> 进行完整性验证。<code>PayloadVerifier</code> 使用 openssl 验证 <code>payload.bin</code> 文件签名，确保更新包未被篡改。</p><ul><li><strong>关键代码片段</strong>：<pre><code class="language-cpp">bool PayloadVerifier::VerifyPayload(const std::string&amp; payload_path) {
    // 使用 openssl 进行签名验证
    if (!openssl_verify(payload_path)) {
        LOG(ERROR) &lt;&lt; &quot;Payload verification failed.&quot;;
        return false;
    }
    return true;
}
</code></pre></li></ul></li><li><p><strong>应用更新包</strong>： <code>PayloadProcessor</code> 负责将下载好的更新包应用到非活动分区（如 <code>slot B</code>）。该模块解析 <code>payload</code> 文件，提取出增量更新信息并应用差异。</p><ul><li><strong>块级差异处理</strong>：<pre><code class="language-cpp">bool PayloadProcessor::ApplyUpdate(const std::string&amp; payload) {
    // 处理块级差异
    for (const auto&amp; operation : operations) {
        if (!ApplyBlockOperation(operation)) {
            LOG(ERROR) &lt;&lt; &quot;Failed to apply block operation.&quot;;
            return false;
        }
    }
    return true;
}
</code></pre></li></ul></li></ul><h4 id="3-分区切换与重启">3. <strong>分区切换与重启</strong></h4><ul><li><p><strong>分区管理</strong>： 更新包应用完成后，<code>update_engine</code> 通过 <code>BootControlInterface</code> 切换分区，让系统在下次启动时从更新后的分区启动。</p><ul><li><strong>关键代码</strong>：<pre><code class="language-cpp">bool BootControlInterface::SetActiveSlot(int slot) {
    // 切换到指定的 slot
    return SetBootSlot(slot);
}
</code></pre></li></ul></li><li><p><strong>重启与验证</strong>： 系统重启后，从新分区启动。若启动成功，<code>update_engine</code> 标记更新为成功；如果启动失败，系统自动回滚到旧分区。</p></li></ul><h4 id="4-更新流程图">4. <strong>更新流程图</strong></h4><pre><code class="language-plaintext">1. APP 层检查更新 ——&gt; 2. 下载 OTA 包 ——&gt; 3. 交由 update_engine
   |
   V
4. 验证 OTA 包 ——&gt; 5. 应用更新包 ——&gt; 6. 切换分区 ——&gt; 7. 重启
   |                    |
   V                    V
8. 成功启动       失败回滚到旧分区
</code></pre><hr><h3 id="三、增量更新详细介绍">三、增量更新详细介绍</h3><p>在 Android 中，增量更新主要有两种方式：<strong>文件增量更新</strong>和<strong>块增量更新</strong>。</p><ol><li><p><strong>文件增量更新</strong><br>文件增量更新基于文件的元数据和内容进行比较。它会根据更新前后文件的内容差异，生成用于更新的文件差异包。这种方式的优势在于更新包的大小相对较小，因为只需要传输变化的文件部分。</p><p><strong>优点</strong>：</p><ul><li>更细粒度地控制文件内容。</li><li>更新包体积相对较小。</li></ul><p><strong>缺点</strong>：</p><ul><li>如果文件变化较大或文件系统发生变化，效果不如块级增量更新。</li></ul></li><li><p><strong>块级增量更新</strong><br>块级更新是基于存储设备上的分区块对比生成的。这种方法按块进行数据比较，而不仅仅是文件。即使文件没有显著变化，如果底层存储块发生了变动（如文件元数据或文件系统元数据发生变化），也会触发块级更新。</p><p><strong>优点</strong>：</p><ul><li>可以处理文件系统和元数据的变化。</li><li>更高效地处理大范围的数据变化。</li></ul><p><strong>缺点</strong>：</p><ul><li>更新包可能比文件级更新略大。</li></ul></li><li><p><strong>增量更新过程</strong>： 增量更新包通常由旧版本和新版本之间的差异生成。<code>update_engine</code> 负责将这些差异应用到非活动分区。无论是文件增量还是块增量，系统都会确保更新包应用后，设备能够在更新的分区上正常启动。</p></li></ol><hr><h3 id="四、增量更新示例流程">四、增量更新示例流程</h3><ol><li><p><strong>启动增量更新</strong>： 设备下载增量更新包后，<code>update_engine</code> 会调用 <code>PayloadProcessor</code> 来解压并应用增量更新。</p></li><li><p><strong>检查分区数据</strong>： 如果是文件级增量更新，系统会检查目标分区上的文件，生成更新前后的文件差异。 如果是块级增量更新，<code>PayloadProcessor</code> 会直接按块比较分区数据，并将差异应用到新的分区。</p></li><li><p><strong>应用差异包</strong>： 通过差异比较生成的差异包会被应用到目标分区（如 <code>slot B</code>）。这意味着 <code>slot A</code> 仍然保持当前状态，直到更新成功为止。</p></li><li><p><strong>切换分区</strong>： 更新完成后，设备重启并启动到已更新的分区（如 <code>slot B</code>）。此时，<code>slot A</code> 保持原始状态，以便在更新失败时进行回滚。</p></li><li><p><strong>验证启动和标记成功</strong>： 如果设备在新分区上成功启动，<code>update_engine</code> 将更新标记为成功。否则，设备会自动回滚到旧分区，并恢复到原始状态。</p></li></ol><hr><h3 id="五、外部库依赖">五、外部库依赖</h3><p><code>update_engine</code> 依赖于以下外部库来实现 OTA 更新功能：</p><ol><li><strong>libchrome</strong>：提供日志记录、线程和调度功能，帮助开发者调试和监控更新过程。</li><li><strong>libcurl</strong>：虽然 <code>update_engine</code> 本身不负责下载，但通过 libcurl 在某些定制场景下实现更新包的获取。</li><li><strong>libprotobuf</strong>：用于解析 <code>payload.bin</code> 文件中包含的 Protocol Buffers 元数据和更新信息。</li><li><strong>openssl</strong>：用于加密验证，确保下载的更新包未经篡改。</li></ol><hr><h3 id="六、调试与日志分析">六、调试与日志分析</h3><p><code>update_engine</code> 生成的日志提供详细的更新过程信息。可以通过以下命令查看：</p><pre><code class="language-bash">adb logcat | grep update_engine
</code></pre><p>常见的调试日志信息包括：</p><ul><li>更新包验证结果</li><li>分区写入进度</li><li>分区切换结果</li></ul><hr><h3 id="七、代码结构">七、代码结构</h3><h4 id="1-代码结构概览">1. 代码结构概览</h4><p><code>update_engine</code> 项目通常位于 AOSP 源代码的 <code>system/update_engine/</code> 目录下，主要负责管理 Android 系统的 OTA（Over-the-Air）更新。它实现了 Android 的无缝更新机制（A/B 分区更新），其中包括后台下载、系统更新和分区切换等功能。</p><p>以下是 <code>update_engine</code> 的代码结构：</p><pre><code>system/update_engine/
│
├── aosp/                      // AOSP 特定代码
├── client/                    // 客户端与 update_engine 的通信接口
├── common/                    // 跨平台的公共代码
├── cros/                      // ChromeOS 特定代码
├── daemon/                    // 守护进程和服务
├── hw/                        // 硬件特定的实现
├── libpayload_consumer/        // 处理更新负载的库
├── payload_generator/         // 生成 OTA 更新负载
├── scripts/                   // 构建与测试脚本
├── tests/                     // 单元测试代码
├── tools/                     // 各类工具
└── update_metadata.proto      // 更新元数据定义
</code></pre><h4 id="2-关键模块详解">2. 关键模块详解</h4><h5 id="21-aosp（aosp-特定代码）">2.1 <code>aosp/</code>（AOSP 特定代码）</h5><p>该目录包含 AOSP 相关的自定义实现，可能包括与其他 Android 系统组件集成的特定逻辑。它处理了 AOSP 中特定平台或系统的更新逻辑。</p><h5 id="22-client（客户端接口）">2.2 <code>client/</code>（客户端接口）</h5><p><code>client/</code> 目录下包含与 <code>update_engine</code> 守护进程进行通信的客户端接口。客户端用于发起更新请求和接收更新状态。</p><ul><li><code>update_engine_client.cc</code>：主要实现了与 <code>update_engine</code> 守护进程的通信逻辑，使用 D-Bus 进行消息传递。</li></ul><h5 id="23-common（通用模块）">2.3 <code>common/</code>（通用模块）</h5><p>这个目录下的代码是跨平台的公共代码，可能在 Android 和其他平台（如 ChromeOS）共享使用：</p><ul><li><code>utils.cc</code>：常用的工具类函数，包含日志、时间管理等通用功能。</li><li><code>metrics_reporter.cc</code>：用于记录并汇报更新过程中产生的性能和使用指标。</li></ul><h5 id="24-daemon（守护进程）">2.4 <code>daemon/</code>（守护进程）</h5><p><code>daemon/</code> 模块实现了 <code>update_engine</code> 的守护进程，它在后台持续运行，负责更新流程的主要逻辑。关键文件有：</p><ul><li><code>update_engine_daemon.cc</code>：守护进程的核心文件，初始化和启动 <code>update_engine</code>，并处理系统更新的主要操作。</li><li><code>service.cc</code>：实现了通过 D-Bus 提供服务的功能，处理外部的更新请求并与客户端交互。</li></ul><h5 id="25-libpayload_consumer（负载处理库）">2.5 <code>libpayload_consumer/</code>（负载处理库）</h5><p>这个模块负责处理更新包（payload），它会解析下载的更新负载，并将其应用到备用分区中。</p><ul><li><code>payload_processor.cc</code>：负责解析和处理增量或全量更新负载，并将其写入目标系统分区（通常是备用分区）。</li></ul><h5 id="26-payload_generator（更新负载生成器）">2.6 <code>payload_generator/</code>（更新负载生成器）</h5><p><code>payload_generator/</code> 负责生成 OTA 更新负载，通常由系统构建工具使用。这个模块包括增量更新负载的生成逻辑：</p><ul><li><code>delta_diff_generator.cc</code>：实现增量更新的生成，通过比较不同版本的文件系统生成更新所需的差异数据。</li></ul><h5 id="27-hw（硬件特定代码）">2.7 <code>hw/</code>（硬件特定代码）</h5><p>这个目录包含与特定硬件平台相关的实现。不同硬件可能需要特定的更新策略和驱动支持。</p><h5 id="28-scripts（脚本）">2.8 <code>scripts/</code>（脚本）</h5><p><code>scripts/</code> 目录包含了一些辅助脚本，用于自动化构建、部署、测试等任务。</p><h5 id="29-tests（测试）">2.9 <code>tests/</code>（测试）</h5><p>该目录包含了 <code>update_engine</code> 的单元测试和集成测试代码。确保各个模块在不同条件下都能正常工作。</p><h5 id="210-tools（工具）">2.10 <code>tools/</code>（工具）</h5><p>工具目录下包含一些调试和诊断工具，用于开发者在调试 OTA 更新功能时使用。</p><hr><p>Android 11 的 OTA 更新流程将更新包的下载与应用分离。APP 层负责检查和下载更新，<code>update_engine</code> 则专注于更新包的验证、应用和分区管理。增量更新技术的引入有效减少了更新包的大小，使得系统更新更加高效。</p><p>参考资料： <a href="https://source.android.com/docs/core/ota">https://source.android.com/docs/core/ota</a> <a href="https://blog.csdn.net/yang_mao_shan/category_12373702.html">https://blog.csdn.net/yang_mao_shan/category_12373702.html</a></p><p>===========The End===========</p></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 九月 27, 2024</p><div class="post__share"></div></footer><nav class="pagination"><div class="pagination__title"><span>Read other posts</span></div><div class="pagination__buttons"><a href="https://blog.nasyes.cn/aosp-otabao-de-zhi-zuoota_from_target_files-de-xiang-xi-jie-shao.html" class="btn previous" rel="prev" aria-label="[MISSING TRANSLATION]:  AOSP OTA包的制作：ota_from_target_files 的详细介绍 "><span class="btn__icon">←</span> <span class="btn__text">AOSP OTA包的制作：ota_from_target_files 的详细介绍</span> </a><a href="https://blog.nasyes.cn/android11xi-tong-fen-qu-jie-shao.html" class="btn next" rel="next" aria-label="[MISSING TRANSLATION]:  Android系统分区构成和解析：以AOSP11为例 "><span class="btn__text">Android系统分区构成和解析：以AOSP11为例</span> <span class="btn__icon">→</span></a></div></nav></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><p>© 2024 Powered by Publii CMS :: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank" rel="noopener">Theme</a> ported by the <a href="https://getpublii.com/customization-service/" target="_blank" rel="noopener">Publii Team</a></p></div></div></footer></div><script defer="defer" src="https://blog.nasyes.cn/assets/js/scripts.min.js?v=74fad06980c30243d91d72c7c57fcdb8"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>