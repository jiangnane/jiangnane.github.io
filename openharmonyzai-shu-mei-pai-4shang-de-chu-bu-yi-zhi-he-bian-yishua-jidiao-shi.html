<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>OpenHarmony在树莓派4B上的初步移植和编译、刷机 - HEIN&#x27;s Blog</title><meta name="robots" content="noindex,nofollow"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="alternate" type="application/atom+xml" href="https://blog.nasyes.cn/feed.xml"><link rel="alternate" type="application/json" href="https://blog.nasyes.cn/feed.json"><meta property="og:title" content="OpenHarmony在树莓派4B上的初步移植和编译、刷机"><meta property="og:site_name" content="HEIN's Blog"><meta property="og:description" content="1. OpenHarmony简介 仓库主页：https://gitee.com/openharmony 项目官网：https://www.openharmony.cn/mainPlay OpenHarmony是由开放原子开源基金会（OpenAtom Foundation）孵化及运营的开源项目，目标是面向全场景、全连接、全智能时代，基于开源的方式，搭建一个智能终端设备操作系统的框架和平台，促进万物互联产业的繁荣发展。 鸿蒙从华为诞生之后，华为在2020年9月和2021年5月分两次将HarmonyOS的基础能力代码全部捐献给开放原子开源基金会（https://www.openatom.org），这是鸿蒙操作系统发展历程中非常重要的事件。所谓“基础能力代码”，是HarmonyOS中与华为自家的产品和商业模式无关的那部分代码。 开放原子开源基金会成立于2020年，是国内第一家开源基金会。 开放原子开源基金会在接收到华为捐赠的代码之后，就遵循 Apache 许可协议代码开源了，同时创立了一个开源项目，并将其命名为 OpenHarmony（开源鸿蒙）。下面是OpenHarmony的部分发展历程，可查阅https://gitee.com/openharmony/docs/tree/master/zh-cn/release-notes 获取更详细的信息。 Android 是一个基于 Linux 的开源软件堆栈，针对多种不同设备类型打造。下图显示了 Android 平台的主要组件。 详情可参考：https://developer.android.google.cn/guide/platform?hl=zh-cn OpenHarmony支持如下几种系统类型： 轻量系统（mini system） 面向MCU类处理器例如Arm Cortex-M、RISC-V&hellip;"><meta property="og:url" content="https://blog.nasyes.cn/openharmonyzai-shu-mei-pai-4shang-de-chu-bu-yi-zhi-he-bian-yishua-jidiao-shi.html"><meta property="og:type" content="article"><link rel="preload" href="https://blog.nasyes.cn/assets/dynamic/fonts/jetbrainsmono/jetbrainsmono.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://blog.nasyes.cn/assets/css/style.css?v=1f557c81d98d81d721608200b8db7e33"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.nasyes.cn/openharmonyzai-shu-mei-pai-4shang-de-chu-bu-yi-zhi-he-bian-yishua-jidiao-shi.html"},"headline":"OpenHarmony在树莓派4B上的初步移植和编译、刷机","datePublished":"2024-05-23T10:06+08:00","dateModified":"2024-05-28T14:17+08:00","description":"1. OpenHarmony简介 仓库主页：https://gitee.com/openharmony 项目官网：https://www.openharmony.cn/mainPlay OpenHarmony是由开放原子开源基金会（OpenAtom Foundation）孵化及运营的开源项目，目标是面向全场景、全连接、全智能时代，基于开源的方式，搭建一个智能终端设备操作系统的框架和平台，促进万物互联产业的繁荣发展。 鸿蒙从华为诞生之后，华为在2020年9月和2021年5月分两次将HarmonyOS的基础能力代码全部捐献给开放原子开源基金会（https://www.openatom.org），这是鸿蒙操作系统发展历程中非常重要的事件。所谓“基础能力代码”，是HarmonyOS中与华为自家的产品和商业模式无关的那部分代码。 开放原子开源基金会成立于2020年，是国内第一家开源基金会。 开放原子开源基金会在接收到华为捐赠的代码之后，就遵循 Apache 许可协议代码开源了，同时创立了一个开源项目，并将其命名为 OpenHarmony（开源鸿蒙）。下面是OpenHarmony的部分发展历程，可查阅https://gitee.com/openharmony/docs/tree/master/zh-cn/release-notes 获取更详细的信息。 Android 是一个基于 Linux 的开源软件堆栈，针对多种不同设备类型打造。下图显示了 Android 平台的主要组件。 详情可参考：https://developer.android.google.cn/guide/platform?hl=zh-cn OpenHarmony支持如下几种系统类型： 轻量系统（mini system） 面向MCU类处理器例如Arm Cortex-M、RISC-V&hellip;","author":{"@type":"Person","name":"HEIN","url":"https://blog.nasyes.cn/authors/hein/"},"publisher":{"@type":"Organization","name":"HEIN"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body><div class="container container--center"><header class="header"><div class="header__logo"><a class="logo" href="https://blog.nasyes.cn/">HEIN&#x27;s Blog</a></div></header><main class="content"><article class="post"><header><h1 class="post__title">OpenHarmony在树莓派4B上的初步移植和编译、刷机</h1><div class="post__meta"><time datetime="2024-05-23T10:06" class="post__date">五月 23, 2024 </time><span class="post__author"><a href="https://blog.nasyes.cn/authors/hein/" class="feed__author">HEIN</a></span></div></header><div class="post__entry"><h2>1. OpenHarmony简介</h2><p>仓库主页：<a href="https://www.openharmony.cn/mainPlay" target="_blank" rel="noopener noreferrer">https://gitee.com/openharmony</a></p><p>项目官网：<a href="https://www.openharmony.cn/mainPlay" target="_blank" rel="noopener noreferrer"></a><a href="https://www.openharmony.cn/mainPlay" target="_blank" rel="noopener noreferrer"></a><a href="https://www.openharmony.cn/mainPlay" target="_blank" rel="noopener noreferrer">https://www.openharmony.cn/mainPlay</a></p><blockquote><p>OpenHarmony是由开放原子开源基金会（OpenAtom Foundation）孵化及运营的开源项目，目标是面向全场景、全连接、全智能时代，基于开源的方式，搭建一个智能终端设备操作系统的框架和平台，促进万物互联产业的繁荣发展。</p></blockquote><div><div><div><div> </div></div>鸿蒙操作系统最早是由华为进行研发和发布，可查阅：<a href="https://www.harmonyos.com/cn/information/">https://www.harmonyos.com/cn/information/</a>获取华为发布鸿蒙的信息。</div><div><div><p data-pid="nAI-2kSQ">鸿蒙从华为诞生之后，华为在2020年9月和2021年5月分两次将HarmonyOS的基础能力代码全部捐献给开放原子开源基金会<svg width="10px" height="10px" viewbox="0 0 15 15" class="css-1dvsrp"><path d="M10.89 9.477l3.06 3.059a1 1 0 0 1-1.414 1.414l-3.06-3.06a6 6 0 1 1 1.414-1.414zM6 10a4 4 0 1 0 0-8 4 4 0 0 0 0 8z" fill="currentColor"></path></svg>（https://www.openatom.org），这是鸿蒙操作系统发展历程中非常重要的事件。所谓“基础能力代码”，是HarmonyOS中与华为自家的产品和商业模式无关的那部分代码。</p><p data-pid="nAI-2kSQ">开放原子开源基金会成立于2020年，是国内第一家开源基金会。</p><p data-pid="7BBS3Zl_">开放原子开源基金会在接收到华为捐赠的代码之后，就遵循 Apache 许可协议代码开源了，同时创立了一个开源项目，并将其命名为 OpenHarmony（开源鸿蒙）。下面是OpenHarmony的部分发展历程，可查阅<a href="https://gitee.com/openharmony/docs/tree/master/zh-cn/release-notes">https://gitee.com/openharmony/docs/tree/master/zh-cn/release-notes</a> 获取更详细的信息。</p></div></div><div>下图是HarmonyOS(右)和OpenHarmony(左)的发展时间线，供参考。</div><div><figure class="post__image"><img loading="lazy" src="https://blog.nasyes.cn/media/posts/3/OH-Tileline.png" alt="" width="2369" height="1347" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/OH-Tileline-xs.png 300w, https://blog.nasyes.cn/media/posts/3/responsive/OH-Tileline-sm.png 480w, https://blog.nasyes.cn/media/posts/3/responsive/OH-Tileline-md.png 768w, https://blog.nasyes.cn/media/posts/3/responsive/OH-Tileline-lg.png 1024w"><figcaption>HarmonyOS(右)和OpenHarmony(左)的发展时间线</figcaption></figure></div><h2>2. OpenHarmony和AOSP的技术架构对比</h2><h3>· OpenHarmony</h3>OpenHarmony整体遵从分层设计，从下向上依次为：内核层、系统服务层、框架层和应用层。系统功能按照“系统 &gt; 子系统 &gt; 组件”逐级展开，在多设备部署场景下，支持根据实际需求裁剪某些非必要的组件。OpenHarmony技术架构如下所示：<br><figure class="post__image"><img loading="lazy" style="outline: 3px solid rgba(var(--color-primary-rgb), 0.55) !important;" src="https://blog.nasyes.cn/media/posts/3/OH-Stack.png" alt="OpenHarmony技术架构" width="1783" height="866" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/OH-Stack-xs.png 300w, https://blog.nasyes.cn/media/posts/3/responsive/OH-Stack-sm.png 480w, https://blog.nasyes.cn/media/posts/3/responsive/OH-Stack-md.png 768w, https://blog.nasyes.cn/media/posts/3/responsive/OH-Stack-lg.png 1024w"><figcaption>OpenHarmony技术架构</figcaption></figure></div><blockquote><div>详情可参考：<a href="https://gitee.com/openharmony#%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84">https://gitee.com/openharmony#技术架构</a></div></blockquote><div><h3>· AOSP</h3><p>Android 是一个基于 Linux 的开源软件堆栈，针对多种不同设备类型打造。下图显示了 Android 平台的主要组件。</p><figure class="post__image"><img loading="lazy" src="https://blog.nasyes.cn/media/posts/3/android-stack_2x-3.png" alt="" width="800" height="1178" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/android-stack_2x-3-xs.png 300w, https://blog.nasyes.cn/media/posts/3/responsive/android-stack_2x-3-sm.png 480w, https://blog.nasyes.cn/media/posts/3/responsive/android-stack_2x-3-md.png 768w, https://blog.nasyes.cn/media/posts/3/responsive/android-stack_2x-3-lg.png 1024w"><figcaption>Android 软件栈</figcaption></figure><blockquote><p>详情可参考：<a href="https://developer.android.google.cn/guide/platform?hl=zh-cn">https://developer.android.google.cn/guide/platform?hl=zh-cn</a></p></blockquote></div><h2>3. OpenHarmony主库版本编译</h2><p>OpenHarmony支持如下几种系统类型：</p><ul><li><p><strong>轻量系统（mini system）</strong></p><p>面向MCU类处理器例如Arm Cortex-M、RISC-V 32位的设备，硬件资源极其有限，支持的设备最小内存为128KiB，可以提供多种轻量级网络协议，轻量级的图形框架，以及丰富的IOT总线读写部件等。可支撑的产品如智能家居领域的连接类模组、传感器设备、穿戴类设备等。</p></li><li><p><strong>小型系统（small system）</strong></p><p>面向应用处理器例如Arm Cortex-A的设备，支持的设备最小内存为1MiB，可以提供更高的安全能力、标准的图形框架、视频编解码的多媒体能力。可支撑的产品如智能家居领域的IP Camera、电子猫眼、路由器以及智慧出行域的行车记录仪等。</p></li><li><p><strong>标准系统（standard system）</strong></p><p>面向应用处理器例如Arm Cortex-A的设备，支持的设备最小内存为128MiB，可以提供增强的交互能力、3D GPU以及硬件合成能力、更多控件以及动效更丰富的图形能力、完整的应用框架。可支撑的产品如高端的冰箱显示屏。</p></li></ul><p>后续内容如果没有特别说明，都是以标准系统为示例进行介绍的。</p><p>官方的文档中也有详细的说明，此处仅作简要总结。</p><h4>3.1 下载源码</h4><p>OpenHarmony的代码以组件的形式开放，开发者可以通过如下其中一种方式获取：</p><ul><li><p><strong>获取方式1</strong>：从码云代码仓库获取。通过repo或git工具从代码仓库中下载，此方式可获取最新代码。</p></li><li><p><strong>获取方式2</strong>：通过<a href="https://gitee.com/link?target=https%3A%2F%2Frepo.harmonyos.com%2F%23%2Fcn%2Fhome">DevEco Marketplace</a>网站获取。访问<a href="https://gitee.com/link?target=https%3A%2F%2Frepo.harmonyos.com%2F%23%2Fcn%2Fhome">DevEco Marketplace</a>网站，查找满足需求的开源发行版，直接下载（或者定制后下载），再通过hpm-cli命令工具将所需的组件及工具链下载、安装到本地。</p></li><li><p><strong>获取方式3</strong>：从镜像站点下载归档后的发行版压缩文件。如果要获取旧版本的源码，也可通过此方式获取，此方式下载速度较快。</p></li><li><p><strong>获取方式4</strong>：从github代码仓库获取。通过repo或git工具从代码仓库中下载，此方式可获取最新代码。</p></li></ul><p>详细获取方式可参考 <a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/get-code/sourcecode-acquire.md">https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/get-code/sourcecode-acquire.md</a></p><h4>3.2 编译构建</h4><p>OpenHarmony编译子系统是以GN和Ninja构建为基座，对构建和配置粒度进行部件化抽象、对内建模块进行功能增强、对业务模块进行功能扩展的系统，该系统提供以下基本功能：</p><ul><li>以部件为最小粒度拼装产品和独立编译。</li><li>支持轻量、小型、标准三种系统的解决方案级版本构建，以及用于支撑应用开发者使用IDE开发的SDK开发套件的构建。</li><li>支持芯片解决方案厂商的灵活定制和独立编译。</li></ul><figure class="post__image"><img loading="lazy" src="https://blog.nasyes.cn/media/posts/3/compilation_process.png" alt="" width="882" height="563" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/compilation_process-xs.png 300w, https://blog.nasyes.cn/media/posts/3/responsive/compilation_process-sm.png 480w, https://blog.nasyes.cn/media/posts/3/responsive/compilation_process-md.png 768w, https://blog.nasyes.cn/media/posts/3/responsive/compilation_process-lg.png 1024w"><figcaption>编译构建流程</figcaption></figure><p>根据官网的提醒，编译环境目前主要支持Ubuntu18.04和Ubuntu20.04（Ubuntu22.04暂不支持）。后面会介绍22.04上的编译适配方法。</p><p>完整的编译步骤可以参考<a href="https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/subsystems/subsys-build-all.md">https://gitee.com/openharmony/docs/blob/master/zh-cn/device-dev/subsystems/subsys-build-all.md</a></p><h4>3.3 打包及刷机</h4><p>在不同的设备和开发板上打包和刷机的方式不完全相同，后面介绍树莓派4B设备上的打包和刷机步骤，可供其它设备参考。</p><h2>4. OpenHarmony在树莓派4B上的编译和刷机步骤</h2><blockquote><p>IT之家 2 月 8 日消息，据<span class="profile_nickname"> OpenAtom OpenHarmony 官方消息，</span>近期，在中国科学院软件研究所的技术支撑下，<span class="accentTextColor">树莓派 4B（Raspberry Pi 4 Model B）开发板顺利通过 OpenHarmony 3.2.4 Release 版本兼容性测评</span>，并 获 颁 OpenHarmony 生 态 产 品 兼 容 性 证 书 ，突破性推动树莓派 4B 开发板加入 OpenHarmony 生态，为 OpenHarmony 落地教育、物联网和嵌入式等开发领域提供了新的支点。<br><a href="https://baijiahao.baidu.com/s?id=1790323159836926636">树莓派 4B 开发板通过开源鸿蒙 OpenHarmony 兼容性测评</a></p></blockquote><p>在OpenHarmony-SIG上可以找到用于兼容性测试的树莓派4B分支，基于3.2R版本。但是这个版本在实际操作后，产生的版本无法在开发板上运行，所以参考它的步骤，做一些调整后，可产生可用的系统镜像。原步骤文档可参考：<a href="https://gitee.com/openharmony-sig/device_board_rpi/blob/OpenHarmony-3.2-Release/rpi4/README_zh.md">https://gitee.com/openharmony-sig/device_board_rpi/blob/OpenHarmony-3.2-Release/rpi4/README_zh.md</a></p><h4>4.1 树莓派4B开发板介绍</h4><p>树莓派由注册于英国的“Raspberry Pi 慈善基金会”开发，<span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">它是一款基于ARM的微型电脑主板。技术文档可参考：<a href="https://datasheets.raspberrypi.com/rpi4/raspberry-pi-4-product-brief.pdf">https://datasheets.raspberrypi.com/rpi4/raspberry-pi-4-product-brief.pdf</a></span></p><figure class="post__image"><img loading="lazy" src="https://blog.nasyes.cn/media/posts/3/rpi4.png" alt="" width="1171" height="723" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/rpi4-xs.png 300w, https://blog.nasyes.cn/media/posts/3/responsive/rpi4-sm.png 480w, https://blog.nasyes.cn/media/posts/3/responsive/rpi4-md.png 768w, https://blog.nasyes.cn/media/posts/3/responsive/rpi4-lg.png 1024w"><figcaption>树莓派4B开发板外观和接口介绍</figcaption></figure><figure class="post__image"><img loading="lazy" src="https://blog.nasyes.cn/media/posts/3/rpi4_specification.jpg" alt="" width="977" height="1235" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/rpi4_specification-xs.jpg 300w, https://blog.nasyes.cn/media/posts/3/responsive/rpi4_specification-sm.jpg 480w, https://blog.nasyes.cn/media/posts/3/responsive/rpi4_specification-md.jpg 768w, https://blog.nasyes.cn/media/posts/3/responsive/rpi4_specification-lg.jpg 1024w"><figcaption>树莓派4B 技术规格</figcaption></figure><h4>4.2 搭建开发环境</h4><p>根据SIG-3.2R分支上的编译步骤进行配置后，多次尝试编译的镜像都有无法启动(黑屏)的问题，所以我们采用拉取主仓库代码+Vendor适配的方式进行配置，多次尝试后，4.0R版本可以运行在树莓派4B的版本上，此处感谢Gitee上 <a href="https://gitee.com/diemit">@diemit</a> 的答疑解惑，帮助解决和排查了很多补丁和编译的问题。</p><h5>1) <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">下载repo脚本文件</span></h5><div><ul><li>注册码云gitee账号。</li><li>注册码云SSH公钥，请参考码云帮助中心。</li><li>安装git客户端和git-lfs并配置用户信息。</li></ul></div><pre class="language-apacheconf"><code>git config --global user.name "yourname"
git config --global user.email "your-email-address"
git config --global credential.helper store</code></pre><div><ul><li>安装码云repo工具，可以执行如下命令。</li></ul></div><pre class="language-apacheconf"><code>curl -s https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 &gt; /usr/local/bin/repo  
pip3 install -i https://repo.huaweicloud.com/repository/pypi/simple requests</code></pre><div><div>如果没有权限，可下载至其他目录，并将其配置到环境变量中<br><pre class="language-apacheconf"><code>mkdir ~/bin
curl https://gitee.com/oschina/repo/raw/fork_flow/repo-py3 -o ~/bin/repo 
chmod a+x ~/bin/repo
pip3 install -i https://repo.huaweicloud.com/repository/pypi/simple requests</code></pre></div></div><pre class="language-apacheconf"><code>vim ~/.bashrc               # 编辑环境变量
export PATH=~/bin:$PATH     # 在环境变量的最后添加一行repo路径信息
source ~/.bashrc            # 应用环境变量</code></pre><h5>2) <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">获取OpenHarmony标准系统源码</span></h5><p><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">通过repo + ssh 下载（需注册公钥，请参考码云帮助中心）。</span></p><div><div><pre class="language-apacheconf"><code>export WORK_SPACE=/home/xxx/OpenHarmony #替换成自己定义的workspace路径
export PROJ_ROOT=$WORK_SPACE/4.0-Release
mkdir $WORK_SPACE
mkdir $PROJ_ROOT
cd $PROJ_ROOT
#repo init -u https://gitee.com/openharmony/manifest -b OpenHarmony-4.0-Release --no-repo-verify
repo init -u https://gitee.com/openharmony/manifest -b refs/tags/OpenHarmony-v4.0-Release --no-repo-verify
repo sync -c
repo forall -c 'git lfs pull'</code></pre></div></div><p>这里要注意，上面注释掉的一行是原来的官方提供的检出4.0R版本的代码的方式，但是经过我的编译和运行测试，发现4.0R分支释放之后仍然是有代码合入的，从而引入了一些问题，导致树莓派4B移植的补丁合入出现兼容性问题。所以为了防止出现此类问题，改为检出4.0R TAG的代码，保证代码的一致性。</p><h5>3) <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">获取编译工具链</span></h5><p>参考<a href="https://gitee.com/openharmony/docs/tree/master/zh-cn/device-dev/quick-start">OpenHamony快速入门文档</a>，基于命令行入门。</p><pre class="language-apacheconf"><code>sudo apt-get update &amp;&amp; sudo apt-get install binutils git git-lfs gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z1-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip m4 bc gnutls-bin python3.8 python3-pip ruby default-jdk libssl-dev libtinfo5 genext2fs u-boot-tools mtools mtd-utils scons gcc-arm-none-eabi abootimg</code></pre><p>此处是基于Ubuntu20.04的版本进行的工具链安装。经过实际测试，在22.04上可以按照此方法进行安装，但是由于Ubuntu22.04的系统默认Python版本是3.10，而OpenHarmony目前的编译工具均基于Python3.8进行编写。所以如果要在22.04上编译OpenHarmony系统，需要手动切换系统默认Python版本为3.8。下面是具体的切换方法，请参考。</p><pre class="language-apacheconf"><code># 手动添加安装源
# 如果添加失败，则手动编辑sources.list文件，把安装源添加到文件最后
sudo echo 'deb https://launchpad.proxy.ustclug.org/deadsnakes/ppa/ubuntu/ jammy main' &gt;&gt; /etc/apt/sources.list

# 添加证书
sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys BA6932366A755776

# 更新源后安装Python3.8
sudo apt update
sudo apt install -y python3.8 libpython3.8-dev python3.8-dev python3.8-distutils
#查看当前安装的Python版本
ls /usr/bin/python*
# 设置Python顺序
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.10 1
sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.8 2
# 如果需要调整python3的顺序，则运行下列命令后选择新的顺序即可
sudo update-alternatives --config python3</code></pre><h5>4) <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">执行预编译脚本prebuilts</span></h5><p><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">在源码根目录下执行脚本，安装编译器及二进制工具。</span></p><div><div><pre class="language-apacheconf"><code>cd $PROJ_ROOT
bash build/prebuilts_download.sh</code></pre></div><div>等待下载完成即可。</div><h5>5) 下载树莓派4B补丁到主库代码目录中</h5><div><pre class="language-apacheconf"><code>git clone -b OpenHarmony-4.0-Release https://gitee.com/ohos-porting-communities/vendor_opc.git vendor/opc
git clone -b OpenHarmony-4.0-Release https://gitee.com/ohos-porting-communities/device_board_opc.git device/board/opc
git clone -b OpenHarmony-4.0-Release https://gitee.com/ohos-porting-communities/device_soc_opc.git device/soc/opc</code></pre></div><h5>6) 补丁合入</h5><p>使用git合入diff补丁</p><div><pre class="language-apacheconf"><code>#device/board/opc/common/patches

#编译白名单补丁：
#001-build.diff -&gt; build

#树莓派4B启用CPU渲染/GPU渲染黑屏修复与其他设备Mesa3D驱动修改补丁：
#002-graphic_2d.diff -&gt; foundation/graphic/graphic_2d</code></pre></div><h5>7) 配置默认启动位置</h5><div><pre class="language-apacheconf"><code>#补丁里树莓派4B默认挂载配置为U盘启动方式，需要修改启动方式为从microSD卡启动
#修改以下文件，切换挂载分区

device/board/opc/rpi4/cfg/fstab.required
device/board/opc/rpi4/cfg/fstab.rpi4</code></pre></div><div>至此代码和编译环境准备完毕。</div></div><h4>4.3 编译、烧录和调试</h4><p>编译阶段就比较简单了，只要前面按照步骤都配置好了，编译过程应该只是时间问题。</p><h5>1) <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">OpenHarmony编译</span></h5><pre class="language-apacheconf"><code>cd $PROJ_ROOT 
./build.sh --product-name rpi4 --ccache --no-prebuilt-sdk</code></pre><div><div>编译成功提示:</div></div><pre class="language-apacheconf"><code>post_process
=====build beryllium successful.</code></pre><div><div>编译生成的文件：</div><div><pre class="language-apacheconf"><code>$PROJ_ROOT/out/rpi4/packages/phone/images/system.img 
$PROJ_ROOT/out/rpi4/packages/phone/images/vendor.img
$PROJ_ROOT/out/rpi4/packages/phone/images/userdata.img
$PROJ_ROOT/out/rpi4/packages/phone/images/ramdisk.img</code></pre></div></div><h5>2) 树莓派4B打包镜像编译</h5><p><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">编译好OpenHarmony的文件之后使用以下命令内核并打包手机boot.img/树莓派4B完整镜像</span></p><pre class="language-apacheconf"><code>#树莓派4B
./build.sh --product-name rpi4 --ccache --no-prebuilt-sdk --build-target rpi_image</code></pre><h5>3) 镜像烧录</h5><pre class="language-apacheconf"><code>#树莓派4B使用Win32DiskImager烧录整合好的rpi_image.img到microSD卡中</code></pre><p>至此树莓派4B即可运行OpenHarmony 4.0R的系统。</p><h5>4) 调试</h5><h6>A. 串口调试</h6><p>串口引脚图如下：</p><figure class="post__image"><img loading="lazy" src="https://blog.nasyes.cn/media/posts/3/rpi4ck.png" alt="" width="1977" height="1069" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/rpi4ck-xs.png 300w, https://blog.nasyes.cn/media/posts/3/responsive/rpi4ck-sm.png 480w, https://blog.nasyes.cn/media/posts/3/responsive/rpi4ck-md.png 768w, https://blog.nasyes.cn/media/posts/3/responsive/rpi4ck-lg.png 1024w"></figure><pre class="language-apacheconf"><code>(1) 连接图中6、8、10三个引脚。
(2) 打开Xshell，新建会话，在连接的协议中选择SERIAL。
(3) 转到串口标签，选择正确的端口号，波特率115200，完成后即可连接。</code></pre><h6>B. 使用HDC工具</h6><pre class="language-apacheconf"><code>(1)hdc_std shell:进入命令行
(2)hdc_std file send {本地系统文件路径} {oh系统文件路径}:发送文件
(3)hdc_std file recv {oh系统文件路径} {本地系统文件路径}:接收文件
(4)hdc_std install XXX.hap:安装hap包</code></pre><h4>5. OpenHarmony设备挑选和移植指南</h4><h4>5.1 官方设备的挑选</h4><p>目前官方社区支持的开发板可以从以下网址中获取信息：</p><p><a href="https://ci.openharmony.cn/workbench/develop/all">https://ci.openharmony.cn/workbench/develop/all</a></p><p>其中支持标准系统的包含以下三款(从左到右分别是恩智浦、意法半导体和瑞芯微三款芯片的板级支持)：</p><figure class="post__image"><img loading="lazy" src="https://blog.nasyes.cn/media/posts/3/standard_dev_board.png" alt="" width="2045" height="859" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/standard_dev_board-xs.png 300w, https://blog.nasyes.cn/media/posts/3/responsive/standard_dev_board-sm.png 480w, https://blog.nasyes.cn/media/posts/3/responsive/standard_dev_board-md.png 768w, https://blog.nasyes.cn/media/posts/3/responsive/standard_dev_board-lg.png 1024w"><figcaption>官方支持的几款标准系统开发板</figcaption></figure><p>其中以RK3568芯片为主的各种国产开发板均基本都可以使用主库代码进行编译刷入，门槛较低，适配性较好。</p><h4>5.2 可移植设备的挑选</h4><p>除了官方社区支持的开发板，还有一种方案就是对现有的设备进行移植。特别是一些支持或兼容支持Android的设备是较为合适的选择。以下参考 <a href="https://ost.51cto.com/posts/20849">https://ost.51cto.com/posts/20849</a> ，根据作者的移植经验和总结，大致梳理一下可移植设备的初步挑选方法。</p><h5>1) <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">移植设备可行性评估</span></h5><p> </p><div>① 确认你要移植的设备可以解锁刷机<br>② 确认你的设备有TWRP类似的第三方Recovery，方便刷机<br>③ 确认有可用的内核源码版本，不是内核源码开源就能移植的，OpenHarmony的内核④ 目前为止是以标准Linux5.10内核为基础的，4.19已不再支持，移植时需要你的设备有5.10或者5.10以上的内核源码，理论上其他版本也可以，但是要求你是内核大神，精通各个版本内核的变动，并了解驱动如何升级降级适配。<br>⑤ 确认设备驱动源码、固件是否可以获取到</div><p>快速评估入口：<a href="https://wiki.postmarketos.org/wiki/Devices">https://wiki.postmarketos.org/wiki/Devices</a></p><p>根据表格中的提示：</p><figure class="post__image align-center"><img loading="lazy" src="https://blog.nasyes.cn/media/posts/3/devices_features_marks.png" alt="" width="381" height="181" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/devices_features_marks-xs.png 300w, https://blog.nasyes.cn/media/posts/3/responsive/devices_features_marks-sm.png 480w, https://blog.nasyes.cn/media/posts/3/responsive/devices_features_marks-md.png 768w, https://blog.nasyes.cn/media/posts/3/responsive/devices_features_marks-lg.png 1024w"></figure><p><span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">尽量选择全Y的设备，至少也要是P，如果某一项没有得到Y或者P，则说明此功能大概率是不可用的状态。</span></p><p>同理，如果选择Testing中的设备，那么要查看Features的可用性，举例树莓派4B：</p><figure class="post__image align-center"><img loading="lazy" src="https://blog.nasyes.cn/media/posts/3/rpi4_features_supported.png" alt="" width="338" height="658" sizes="(min-width: 920px) 703px, (min-width: 700px) calc(82vw - 35px), calc(100vw - 81px)" srcset="https://blog.nasyes.cn/media/posts/3/responsive/rpi4_features_supported-xs.png 300w, https://blog.nasyes.cn/media/posts/3/responsive/rpi4_features_supported-sm.png 480w, https://blog.nasyes.cn/media/posts/3/responsive/rpi4_features_supported-md.png 768w, https://blog.nasyes.cn/media/posts/3/responsive/rpi4_features_supported-lg.png 1024w"></figure><p>总之，查询后设备的特性支持的越多，移植成功的概率就越高。</p><h5>2) <span style="color: var(--text-primary-color); font-family: var(--editor-font-family); font-size: inherit; font-weight: var(--font-weight-normal);">移植概述</span></h5><p> </p><div>① 准备OpenHarmony代码编译环境，下载源码（社区有大量帖子介绍OH环境安装，在此不再重复介绍）<br>② 官方设备（rk3568）编译一次确认环境配置正确<br>③ 准备postmarketOS编译环境，并进行一次编译（方便获取boot配置，内核配置，驱动固件等）<br>④ 利用第三方内核移植加入OH内核特性的方式，移植适配内核<br>⑤ 移植适配OH的init启动脚本，图形渲染框架<br>⑥ 编译OH系统刷机文件<br>⑦ 利用解包打包工具，打包出自己的boot.img<br>⑧ 利用twrp刷入boot.img，system.img，vendor.img实现OH的启动<br><h5>3) 移植适配相关知识储备</h5><p> </p>① 操作系统相关知识，设备启动相关知识<br>② Linux内核相关知识，驱动相关知识<br>③ OpenHarmony系统相关知识<br>④ Linux操作系统命令相关知识<br>⑤ 设备（安卓手机，平板，开发板等）相关知识</div><div><br><p>===========The End===========</p></div></div><footer class="wrapper post__footer"><p class="post__last-updated">This article was updated on 五月 28, 2024</p><div class="post__share"></div></footer><nav class="pagination"><div class="pagination__title"><span>Read other posts</span></div><div class="pagination__buttons"><a href="https://blog.nasyes.cn/aosphe-lineageosde-dai-ma-jian-chugou-jianshua-ji.html" class="btn previous" rel="prev" aria-label="[MISSING TRANSLATION]:  AOSP和LineageOS的代码检出、构建、刷机 "><span class="btn__icon">←</span> <span class="btn__text">AOSP和LineageOS的代码检出、构建、刷机</span> </a><a href="https://blog.nasyes.cn/aosp-fwk-tian-jia-xin-fang-fa-bao-cuonew-api-must-be-flagged-with-flaggedapi.html" class="btn next" rel="next" aria-label="[MISSING TRANSLATION]:  AOSP FWK 添加新方法报错：New API must be flagged with @FlaggedApi "><span class="btn__text">AOSP FWK 添加新方法报错：New API must be flagged with @FlaggedApi</span> <span class="btn__icon">→</span></a></div></nav></article></main><footer class="footer"><div class="footer__inner"><div class="footer__copyright"><p>© 2024 Powered by Publii CMS :: <a href="https://github.com/panr/hugo-theme-terminal" target="_blank" rel="noopener">Theme</a> ported by the <a href="https://getpublii.com/customization-service/" target="_blank" rel="noopener">Publii Team</a></p></div></div></footer></div><script defer="defer" src="https://blog.nasyes.cn/assets/js/scripts.min.js?v=74fad06980c30243d91d72c7c57fcdb8"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>